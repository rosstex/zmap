From 3551224099ee15b3f84dc710bd31d8e5907bd88d Mon Sep 17 00:00:00 2001
From: Ross Teixeira <rapt@cs.princeton.edu>
Date: Wed, 18 Mar 2020 05:50:27 +0000
Subject: [PATCH 1/1] ipv6 changes

---
 capture.sh                                    |   3 +
 compile.sh                                    |   2 +
 ipv6.txt                                      |   1 +
 run_zmap.sh                                   |   4 +
 src/CMakeLists.txt                            |   5 +
 src/probe_modules/module_icmp6_nmap_echo_1.c  | 210 +++++++++++++++++
 src/probe_modules/module_icmp6_nmap_echo_2.c  | 212 +++++++++++++++++
 .../module_icmp6_nmap_node_req.c              | 211 +++++++++++++++++
 src/probe_modules/module_ipv6_nmap_tcp.c      | 218 ++++++++++++++++++
 src/probe_modules/module_ipv6_nmap_udp.c      | 154 +++++++++++++
 src/probe_modules/module_ipv6_udp.c           |   2 +
 src/probe_modules/probe_modules.c             |  12 +-
 12 files changed, 1033 insertions(+), 1 deletion(-)
 create mode 100755 capture.sh
 create mode 100755 compile.sh
 create mode 100644 ipv6.txt
 create mode 100755 run_zmap.sh
 create mode 100644 src/probe_modules/module_icmp6_nmap_echo_1.c
 create mode 100644 src/probe_modules/module_icmp6_nmap_echo_2.c
 create mode 100644 src/probe_modules/module_icmp6_nmap_node_req.c
 create mode 100644 src/probe_modules/module_ipv6_nmap_tcp.c
 create mode 100644 src/probe_modules/module_ipv6_nmap_udp.c

diff --git a/capture.sh b/capture.sh
new file mode 100755
index 0000000..1da2a36
--- /dev/null
+++ b/capture.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+sudo tshark -V -f "src host fe80::1e69:7aff:fe60:7aa5" -P -o udp.check_checksum:TRUE -o tcp.check_checksum:TRUE
\ No newline at end of file
diff --git a/compile.sh b/compile.sh
new file mode 100755
index 0000000..76c63d1
--- /dev/null
+++ b/compile.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+cd build && sudo make install
diff --git a/ipv6.txt b/ipv6.txt
new file mode 100644
index 0000000..21c8db6
--- /dev/null
+++ b/ipv6.txt
@@ -0,0 +1 @@
+2001:0000:3238:DFE1:63:0000:0000:FEFB
diff --git a/run_zmap.sh b/run_zmap.sh
new file mode 100755
index 0000000..60acbe8
--- /dev/null
+++ b/run_zmap.sh
@@ -0,0 +1,4 @@
+#!/bin/bash
+./compile.sh
+wait
+sudo zmap -p 20023 -M $1 --ipv6-target-file=ipv6.txt --ipv6-source-ip=fe80::1e69:7aff:fe60:7aa5 --probe-args=$2
\ No newline at end of file
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index e8a179d..9a28945 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -44,6 +44,11 @@ set(PROBE_MODULE_SOURCES
     probe_modules/module_ipv6_udp.c
     probe_modules/module_ipv6_udp_dns.c
     probe_modules/module_icmp6_echoscan.c
+    probe_modules/module_icmp6_nmap_echo_1.c
+    probe_modules/module_icmp6_nmap_echo_2.c
+    probe_modules/module_icmp6_nmap_node_req.c
+    probe_modules/module_ipv6_nmap_tcp.c
+    probe_modules/module_ipv6_nmap_udp.c
 )
 
 set(SOURCES
diff --git a/src/probe_modules/module_icmp6_nmap_echo_1.c b/src/probe_modules/module_icmp6_nmap_echo_1.c
new file mode 100644
index 0000000..f342048
--- /dev/null
+++ b/src/probe_modules/module_icmp6_nmap_echo_1.c
@@ -0,0 +1,210 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP echo request (ping) scans
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp6_nmap_echo_1;
+
+int icmp6_nmap_echo_1_global_initialize(struct state_conf *conf)
+{
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_icmp6_nmap_echo_1.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_echo_1.pcap_filter, conf->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_1_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+
+    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
+	// ICMPv6 header plus 8 bytes of data (validation)
+	uint16_t payload_len = sizeof(struct icmp6_hdr) + 120;
+    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
+
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	make_icmp6_header(icmp6_header);
+
+	char *payload = (char *)(&icmp6_header[1]);
+	memset(payload, 0x00, 120);
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_1_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, UNUSED int probe_num, UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	
+	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
+
+	// // Include validation in ICMPv6 payload data
+	// icmp6_header->icmp6_data32[1] = validation[0];
+	// icmp6_header->icmp6_data32[2] = validation[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	icmp6_header->icmp6_code = 9;
+	icmp6_header->icmp6_id= htons(999);
+	icmp6_header->icmp6_seq = htons(295);
+
+	icmp6_header->icmp6_cksum = 0;
+	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
+                &ip6_header->ip6_src,
+		        &ip6_header->ip6_dst,
+				icmp6_header,
+				120
+                );
+
+	// ip6_header->ip6_ctlun.ip6_un1.ip6_un1_flow = 0;
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp6_nmap_echo_1_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
+
+	fprintf(fp, "icmp { type: %u | code: %u "
+			"| checksum: %#04X | id: %u | seq: %u }\n",
+			icmp6_header->icmp6_type,
+			icmp6_header->icmp6_code,
+			ntohs(icmp6_header->icmp6_cksum),
+			ntohs(icmp6_header->icmp6_id),
+			ntohs(icmp6_header->icmp6_seq)
+		);
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+
+static int icmp6_validate_packet(const struct ip *ip_hdr,
+		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
+{
+    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
+
+	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
+		return 0;
+	}
+
+    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
+	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
+		// buffer not large enough to contain expected icmp header
+		return 0;
+	}
+
+    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
+	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
+
+	return 1;
+
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
+        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
+
+        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
+        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
+			return 0;
+		}
+
+		// Use inner headers for validation
+		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
+		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
+
+		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
+        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
+			     (uint8_t *) validation);
+	}
+	// validate icmp id
+	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+
+	// Validate ICMPv6 data
+	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void icmp6_nmap_echo_1_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+	{.name="type", .type="int", .desc="icmp message type"},
+	{.name="code", .type="int", .desc="icmp message sub type code"},
+	{.name="icmp-id", .type="int", .desc="icmp id number"},
+	{.name="seq", .type="int", .desc="icmp sequence number"},
+    {.name="classification", .type="string", .desc="probe module classification"},
+	{.name="success", .type="int", .desc="did probe module classify response as success"}
+};
+
+
+probe_module_t module_icmp6_nmap_echo_1 = {
+	.name = "icmp6_nmap_echo_1",
+	.packet_length = 182, // 14 Eth + 40 IPv6 + 8 ICMP6 + 120
+	.pcap_filter = "icmp6", // and icmp6[0]=!8",
+	.pcap_snaplen =  500,
+	.port_args = 1,
+	.global_initialize = &icmp6_nmap_echo_1_global_initialize,
+	.thread_initialize = &icmp6_nmap_echo_1_init_perthread,
+	.make_packet = &icmp6_nmap_echo_1_make_packet,
+	.print_packet = &icmp6_nmap_echo_1_print_packet,
+	.process_packet = &icmp6_nmap_echo_1_process_packet,
+	.validate_packet = &icmp6_validate_packet,
+	.close = NULL,
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 7};
+
diff --git a/src/probe_modules/module_icmp6_nmap_echo_2.c b/src/probe_modules/module_icmp6_nmap_echo_2.c
new file mode 100644
index 0000000..eb8fbb3
--- /dev/null
+++ b/src/probe_modules/module_icmp6_nmap_echo_2.c
@@ -0,0 +1,212 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP echo request (ping) scans
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp6_nmap_echo_2;
+
+int icmp6_nmap_echo_2_global_initialize(struct state_conf *conf)
+{
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_icmp6_nmap_echo_2.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_echo_2.pcap_filter, conf->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_2_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+
+    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
+	// ICMPv6 header plus 8 bytes of data (validation)
+	uint16_t payload_len = sizeof(struct icmp6_hdr) + 150; // includes extra bits for validation
+    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
+
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	make_icmp6_header(icmp6_header);
+
+	char *payload = (char *)(&icmp6_header[1]);
+	memset(payload, 0x00, 150);
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_2_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, UNUSED int probe_num, UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	
+	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
+
+	// // Include validation in ICMPv6 payload data
+	// icmp6_header->icmp6_data32[1] = validation[0];
+	// icmp6_header->icmp6_data32[2] = validation[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	// icmp6_header->icmp6_id= icmp_idnum;
+
+
+	icmp6_header->icmp6_id = htons(1000);
+	icmp6_header->icmp6_seq = htons(296);
+
+	// TODO: add sensible TOS value
+
+	icmp6_header->icmp6_cksum = 0;
+	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
+                &ip6_header->ip6_src,
+		        &ip6_header->ip6_dst,
+				icmp6_header,
+				150
+                );
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp6_nmap_echo_2_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
+
+	fprintf(fp, "icmp { type: %u | code: %u "
+			"| checksum: %#04X | id: %u | seq: %u }\n",
+			icmp6_header->icmp6_type,
+			icmp6_header->icmp6_code,
+			ntohs(icmp6_header->icmp6_cksum),
+			ntohs(icmp6_header->icmp6_id),
+			ntohs(icmp6_header->icmp6_seq)
+		);
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+
+static int icmp6_validate_packet(const struct ip *ip_hdr,
+		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
+{
+    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
+
+	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
+		return 0;
+	}
+
+    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
+	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
+		// buffer not large enough to contain expected icmp header
+		return 0;
+	}
+
+    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
+	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
+
+	return 1;
+
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
+        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
+
+        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
+        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
+			return 0;
+		}
+
+		// Use inner headers for validation
+		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
+		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
+
+		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
+        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
+			     (uint8_t *) validation);
+	}
+	// validate icmp id
+	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+
+	// Validate ICMPv6 data
+	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void icmp6_nmap_echo_2_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+	{.name="type", .type="int", .desc="icmp message type"},
+	{.name="code", .type="int", .desc="icmp message sub type code"},
+	{.name="icmp-id", .type="int", .desc="icmp id number"},
+	{.name="seq", .type="int", .desc="icmp sequence number"},
+    {.name="classification", .type="string", .desc="probe module classification"},
+	{.name="success", .type="int", .desc="did probe module classify response as success"}
+};
+
+
+probe_module_t module_icmp6_nmap_echo_2 = {
+	.name = "icmp6_nmap_echo_2",
+	.packet_length = 212, // 62, // ICMPv4: 64 bit --> Why 62? ICMPv6 also 64 bit --> Leave 64
+	.pcap_filter = "icmp6",
+	.pcap_snaplen = 300, // 14 ethernet header + 40 IPv6 header + 8 ICMPv6 header + 40 inner IPv6 header + 8 inner ICMPv6 header + 8 payload
+	.port_args = 1,
+	.global_initialize = &icmp6_nmap_echo_2_global_initialize,
+	.thread_initialize = &icmp6_nmap_echo_2_init_perthread,
+	.make_packet = &icmp6_nmap_echo_2_make_packet,
+	.print_packet = &icmp6_nmap_echo_2_print_packet,
+	.process_packet = &icmp6_nmap_echo_2_process_packet,
+	.validate_packet = &icmp6_validate_packet,
+	.close = NULL,
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 7};
+
diff --git a/src/probe_modules/module_icmp6_nmap_node_req.c b/src/probe_modules/module_icmp6_nmap_node_req.c
new file mode 100644
index 0000000..2e5feae
--- /dev/null
+++ b/src/probe_modules/module_icmp6_nmap_node_req.c
@@ -0,0 +1,211 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP echo request (ping) scans
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp6_nmap_node_req;
+
+int icmp6_nmap_node_req_global_initialize(struct state_conf *conf)
+{
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_icmp6_nmap_node_req.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_node_req.pcap_filter, conf->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_node_req_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+
+    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
+	uint16_t payload_len = sizeof(struct icmp6_hdr) + 8 + 16; // nonce + requested IP
+    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
+
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	make_icmp6_header(icmp6_header); // unnecessary?
+	char *payload = (char *)(&icmp6_header[1]);
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_node_req_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	
+	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
+
+	// // Include validation in ICMPv6 payload data
+	// icmp6_header->icmp6_data32[1] = validation[0];
+	// icmp6_header->icmp6_data32[2] = validation[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	icmp6_header->icmp6_type = 139;
+	icmp6_header->icmp6_code = 0;
+
+	icmp6_header->icmp6_data16[0] = htons(4);
+	icmp6_header->icmp6_data16[1] = htons(2);
+
+	struct in6_addr* data = &icmp6_header[2];
+	*data = ip6_header->ip6_dst;
+
+		// icmp6_header->icmp6_id= icmp_idnum;
+	icmp6_header->icmp6_cksum = 0;
+	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
+                &ip6_header->ip6_src,
+		        &ip6_header->ip6_dst,
+				icmp6_header,
+				16+8
+                );
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp6_nmap_node_req_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
+
+	fprintf(fp, "icmp { type: %u | code: %u "
+			"| checksum: %#04X | id: %u | seq: %u }\n",
+			icmp6_header->icmp6_type,
+			icmp6_header->icmp6_code,
+			ntohs(icmp6_header->icmp6_cksum),
+			ntohs(icmp6_header->icmp6_id),
+			ntohs(icmp6_header->icmp6_seq)
+		);
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+
+static int icmp6_nmap_node_req_validate_packet(const struct ip *ip_hdr,
+		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
+{
+    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
+
+	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
+		return 0;
+	}
+
+    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
+	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
+		// buffer not large enough to contain expected icmp header
+		return 0;
+	}
+
+    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
+	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
+
+	return 1;
+
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
+        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
+
+        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
+        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
+			return 0;
+		}
+
+		// Use inner headers for validation
+		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
+		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
+
+		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
+        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
+			     (uint8_t *) validation);
+	}
+	// validate icmp id
+	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+
+	// Validate ICMPv6 data
+	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void icmp6_nmap_node_req_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+	{.name="type", .type="int", .desc="icmp message type"},
+	{.name="code", .type="int", .desc="icmp message sub type code"},
+	{.name="icmp-id", .type="int", .desc="icmp id number"},
+	{.name="seq", .type="int", .desc="icmp sequence number"},
+    {.name="classification", .type="string", .desc="probe module classification"},
+	{.name="success", .type="int", .desc="did probe module classify response as success"}
+};
+
+
+probe_module_t module_icmp6_nmap_node_req = {
+	.name = "icmp6_nmap_node_req",
+	.packet_length = 86,
+	.pcap_filter = "icmp6", // and icmp6[0]=!8",
+	.pcap_snaplen =  500, // 14 ethernet header + 40 IPv6 header + 8 ICMPv6 header + 40 inner IPv6 header + 8 inner ICMPv6 header + 8 payload
+	.port_args = 1,
+	.global_initialize = &icmp6_nmap_node_req_global_initialize,
+	.thread_initialize = &icmp6_nmap_node_req_init_perthread,
+	.make_packet = &icmp6_nmap_node_req_make_packet,
+	.print_packet = &icmp6_nmap_node_req_print_packet,
+	.process_packet = &icmp6_nmap_node_req_process_packet,
+	.validate_packet = &icmp6_nmap_node_req_validate_packet,
+	.close = NULL,
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 7};
+
diff --git a/src/probe_modules/module_ipv6_nmap_tcp.c b/src/probe_modules/module_ipv6_nmap_tcp.c
new file mode 100644
index 0000000..72c6aa9
--- /dev/null
+++ b/src/probe_modules/module_ipv6_nmap_tcp.c
@@ -0,0 +1,218 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing TCP SYN scans over IPv6
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../fieldset.h"
+#include "probe_modules.h"
+#include "packet.h"
+
+probe_module_t module_ipv6_nmap_tcp;
+static char* packet_type = NULL;
+static uint32_t num_ports;
+
+int ipv6_nmap_tcp_global_initialize(struct state_conf *state)
+{
+	num_ports = state->source_port_last - state->source_port_first + 1;
+
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_ipv6_nmap_tcp.pcap_filter, "%s && ip6 dst host %s", module_ipv6_nmap_tcp.pcap_filter, state->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+    if(state->probe_args)
+    {
+        char *probe_args = state->probe_args;
+        if(strcmp(probe_args, "t5") == 0) 
+        {
+            packet_type = strdup(probe_args);
+        }
+        else if(strcmp(probe_args, "t6") == 0) 
+        {
+            packet_type = strdup(probe_args);
+        }
+        else if(strcmp(probe_args, "t7") == 0)
+        {
+            packet_type = strdup(probe_args);
+        }
+        else
+        {
+            printf("Invalid probe argument: options are: {t5 t6 t7}\n");
+            return EXIT_FAILURE;
+        }
+    }
+    else
+    {
+        packet_type = strdup("t5"); 
+    }
+
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_tcp_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+	struct ip6_hdr *ip6_header = (struct ip6_hdr*)(&eth_header[1]);
+	uint16_t payload_len = 40; // 20 TCP + 20 TCP Options
+	make_ip6_header(ip6_header, IPPROTO_TCP, payload_len);
+	struct tcphdr *tcp_header = (struct tcphdr*)(&ip6_header[1]);
+	make_tcp_header(tcp_header, dst_port, TH_SYN);
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_tcp_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip, UNUSED ipaddr_n_t dst_ip,
+        uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr*) (&eth_header[1]);
+	struct tcphdr *tcp_header = (struct tcphdr*) (&ip6_header[1]);
+	void *tcp_options = (void *)(&tcp_header[1]);
+	uint32_t tcp_seq = validation[0];
+	uint8_t *tcp_opts;
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	tcp_header->th_sport = htons(get_src_port(num_ports,
+				probe_num, validation));
+	tcp_header->th_seq = 100;
+	tcp_header->th_off = 10;
+
+	if(strcmp(packet_type, "t5") == 0)
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(31337);
+        tcp_header->th_flags = TH_SYN;
+    }
+    else if(strcmp(packet_type, "t6") == 0)
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(32768);
+		// ip_header->ip_off = htons(IP_DF); IPv6 only fragments at end
+        tcp_header->th_flags = TH_ACK;
+    }
+    else
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0F\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(65535);
+        tcp_header->th_flags = (TH_FIN | TH_PUSH | TH_URG);
+    }
+
+	memcpy(tcp_options, tcp_opts, 20);
+
+	tcp_header->th_sum = tcp6_checksum(2*sizeof(struct tcphdr),
+			&ip6_header->ip6_src, &ip6_header->ip6_dst, tcp_header);
+
+	return EXIT_SUCCESS;
+}
+
+void ipv6_nmap_tcp_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct tcphdr *tcph = (struct tcphdr *) &iph[1];
+	fprintf(fp, "tcp { source: %u | dest: %u | seq: %u | checksum: %#04X }\n",
+			ntohs(tcph->th_sport),
+			ntohs(tcph->th_dport),
+			ntohl(tcph->th_seq),
+			ntohs(tcph->th_sum));
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+int ipv6_nmap_tcp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+		__attribute__((unused))uint32_t *src_ip,
+		uint32_t *validation)
+{
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) ip_hdr;
+
+	if (ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_TCP) {
+		return 0;
+	}
+	if ((ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen)) > len) {
+		// buffer not large enough to contain expected tcp header, i.e. IPv6 payload
+		return 0;
+	}
+	struct tcphdr *tcp_hdr = (struct tcphdr*) (&ipv6_hdr[1]);
+	uint16_t sport = tcp_hdr->th_sport;
+	uint16_t dport = tcp_hdr->th_dport;
+	// validate source port
+	if (ntohs(sport) != zconf.target_port) {
+		return 0;
+	}
+	// validate destination port
+	if (!check_dst_port(ntohs(dport), num_ports, validation)) {
+		return 0;
+	}
+	// validate tcp acknowledgement number
+	if (htonl(tcp_hdr->th_ack) != htonl(validation[0])+1) {
+		return 0;
+	}
+	return 1;
+}
+
+void ipv6_nmap_tcp_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ether_header *eth_hdr = (struct ether_header *) packet;
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) (&eth_hdr[1]);
+	// struct tcphdr *tcp_hdr = (struct tcphdr*) (&ipv6_hdr[1]);
+	uint32_t packet_size = htons(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
+	{.name = "sport",  .type = "int", .desc = "TCP source port"},
+	{.name = "dport",  .type = "int", .desc = "TCP destination port"},
+	{.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
+	{.name = "classification", .type="string", .desc = "packet classification"},
+	{.name = "success", .type="int", .desc = "is response considered success"}
+};
+
+probe_module_t module_ipv6_nmap_tcp = {
+	.name = "ipv6_nmap_tcp",
+	.packet_length = 94, // 14 Ethernet + 40 IPv6 + 20 TCP + 20 Options
+	.pcap_filter = "ip6 proto 6",
+	.pcap_snaplen = 116, // was 96 for IPv4
+	.port_args = 1,
+	.global_initialize = &ipv6_nmap_tcp_global_initialize,
+	.thread_initialize = &ipv6_nmap_tcp_init_perthread,
+	.make_packet = &ipv6_nmap_tcp_make_packet,
+	.print_packet = &ipv6_nmap_tcp_print_packet,
+	.process_packet = &ipv6_nmap_tcp_process_packet,
+	.validate_packet = &ipv6_nmap_tcp_validate_packet,
+	.close = NULL,
+	.helptext = "Probe module that implements nmap closed port probes",
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 6};
+
diff --git a/src/probe_modules/module_ipv6_nmap_udp.c b/src/probe_modules/module_ipv6_nmap_udp.c
new file mode 100644
index 0000000..2cda6a0
--- /dev/null
+++ b/src/probe_modules/module_ipv6_nmap_udp.c
@@ -0,0 +1,154 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing arbitrary UDP scans over IPv6
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../../lib/xalloc.h"
+#include "../../lib/lockfd.h"
+#include "logger.h"
+#include "probe_modules.h"
+#include "packet.h"
+#include "aesrand.h"
+#include "state.h"
+#include "module_udp.h"
+
+#define ICMP_UNREACH_HEADER_SIZE 8
+
+static int num_ports;
+
+probe_module_t module_ipv6_nmap_udp;
+
+int ipv6_nmap_udp_global_initialize(struct state_conf *conf) {
+	num_ports = conf->source_port_last - conf->source_port_first + 1;
+
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_udp_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,\
+		void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+	struct ip6_hdr *ipv6_header = (struct ip6_hdr*)(&eth_header[1]);
+	uint16_t payload_len = 308; // 8 UDP + 300 Payload. htons is called by make_ip6_header
+	make_ip6_header(ipv6_header, IPPROTO_UDP, payload_len);
+
+	struct udphdr *udp_header = (struct udphdr*)(&ipv6_header[1]);
+	make_udp_header(udp_header, zconf.target_port, payload_len);
+
+	char* payload = (char*)(&udp_header[1]);
+	memset(payload, 0x43, 300);
+
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_udp_make_packet(void *buf, UNUSED size_t *buf_len, __attribute__((unused)) ipaddr_n_t src_ip,
+		__attribute__((unused)) ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
+{
+	// From module_ipv6_nmap_udp_dns
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr*) (&eth_header[1]);
+	struct udphdr *udp_header= (struct udphdr *) &ip6_header[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	// ip_header->ip_id = htons(0x1042); doesn't exist in IPv6
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+	udp_header->uh_sport = htons(43213);
+
+	udp_header->uh_sum = ipv6_udp_checksum(&ip6_header->ip6_src, &ip6_header->ip6_dst, udp_header);
+
+	return EXIT_SUCCESS;
+}
+
+void ipv6_nmap_udp_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct udphdr *udph  = (struct udphdr*) &iph[1];
+	fprintf(fp, "udp { source: %u | dest: %u | checksum: %#04X }\n",
+		ntohs(udph->uh_sport),
+		ntohs(udph->uh_dport),
+		ntohs(udph->uh_sum));
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+void ipv6_nmap_udp_process_packet(const u_char *packet, UNUSED uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+
+int ipv6_nmap_udp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+		UNUSED uint32_t *src_ip, uint32_t *validation)
+{
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) ip_hdr;
+
+	if (ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_UDP) {
+		return 0;
+	}
+
+	if ((ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen)) > len) {
+		// buffer not large enough to contain expected UDP header, i.e. IPv6 payload
+		return 0;
+	}
+	if (!ipv6_udp_validate_packet(ipv6_hdr, len, NULL, validation)) {
+		return 0;
+	}
+	return 1;
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
+	{.name = "sport", .type = "int", .desc = "UDP source port"},
+	{.name = "dport", .type = "int", .desc = "UDP destination port"},
+	{.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
+	{.name = "classification", .type="string", .desc = "packet classification"},
+	{.name = "success", .type="int", .desc = "is response considered success"},
+};
+
+probe_module_t module_ipv6_nmap_udp = {
+	.name = "ipv6_nmap_udp",
+	.packet_length = 362, // 14 Ethernet, 40 IPv6, 8 UDP, 300 Payload
+	.pcap_filter = "ip6 proto 17",
+	.pcap_snaplen = 1500,
+	.port_args = 1,
+	.thread_initialize = &ipv6_nmap_udp_init_perthread,
+	.global_initialize = &ipv6_nmap_udp_global_initialize,
+	.make_packet = &ipv6_nmap_udp_make_packet,
+	.print_packet = &ipv6_nmap_udp_print_packet,
+	.validate_packet = &ipv6_nmap_udp_validate_packet,
+	.process_packet = &ipv6_nmap_udp_process_packet,
+	.close = NULL,
+	.helptext = "Probe module that implements nmap closed port probes",
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 6};
diff --git a/src/probe_modules/module_ipv6_udp.c b/src/probe_modules/module_ipv6_udp.c
index cdd8fb4..9cd2f39 100644
--- a/src/probe_modules/module_ipv6_udp.c
+++ b/src/probe_modules/module_ipv6_udp.c
@@ -119,6 +119,8 @@ int ipv6_udp_global_initialize(struct state_conf *conf) {
 
 	FILE *inp;
 
+	log_info("udp", "ASFDSAFDASFADS HI");
+
 	num_ports = conf->source_port_last - conf->source_port_first + 1;
 	udp_set_num_ports(num_ports);
 
diff --git a/src/probe_modules/probe_modules.c b/src/probe_modules/probe_modules.c
index 1562086..15fc39f 100644
--- a/src/probe_modules/probe_modules.c
+++ b/src/probe_modules/probe_modules.c
@@ -35,6 +35,11 @@ extern probe_module_t module_ipv6_tcp_synopt;
 extern probe_module_t module_ipv6_udp;
 extern probe_module_t module_ipv6_udp_dns;
 extern probe_module_t module_icmp6_echoscan;
+extern probe_module_t module_icmp6_nmap_echo_1;
+extern probe_module_t module_icmp6_nmap_echo_2;
+extern probe_module_t module_icmp6_nmap_node_req;
+extern probe_module_t module_ipv6_nmap_tcp;
+extern probe_module_t module_ipv6_nmap_udp;
 
 // ADD YOUR MODULE HERE
 
@@ -54,7 +59,12 @@ probe_module_t* probe_modules[] = {
 	&module_ipv6_tcp_synopt,
 	&module_ipv6_udp,
 	&module_ipv6_udp_dns,
-	&module_icmp6_echoscan
+	&module_icmp6_echoscan,
+	&module_icmp6_nmap_echo_1,
+	&module_icmp6_nmap_echo_2,
+	&module_icmp6_nmap_node_req,
+	&module_ipv6_nmap_tcp,
+	&module_ipv6_nmap_udp
 	// ADD YOUR MODULE HERE
 };
 
-- 
2.20.1

