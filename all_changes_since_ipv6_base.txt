From 3551224099ee15b3f84dc710bd31d8e5907bd88d Mon Sep 17 00:00:00 2001
From: Ross Teixeira <rapt@cs.princeton.edu>
Date: Wed, 18 Mar 2020 05:50:27 +0000
Subject: [PATCH 1/3] ipv6 changes

---
 capture.sh                                    |   3 +
 compile.sh                                    |   2 +
 ipv6.txt                                      |   1 +
 run_zmap.sh                                   |   4 +
 src/CMakeLists.txt                            |   5 +
 src/probe_modules/module_icmp6_nmap_echo_1.c  | 210 +++++++++++++++++
 src/probe_modules/module_icmp6_nmap_echo_2.c  | 212 +++++++++++++++++
 .../module_icmp6_nmap_node_req.c              | 211 +++++++++++++++++
 src/probe_modules/module_ipv6_nmap_tcp.c      | 218 ++++++++++++++++++
 src/probe_modules/module_ipv6_nmap_udp.c      | 154 +++++++++++++
 src/probe_modules/module_ipv6_udp.c           |   2 +
 src/probe_modules/probe_modules.c             |  12 +-
 12 files changed, 1033 insertions(+), 1 deletion(-)
 create mode 100755 capture.sh
 create mode 100755 compile.sh
 create mode 100644 ipv6.txt
 create mode 100755 run_zmap.sh
 create mode 100644 src/probe_modules/module_icmp6_nmap_echo_1.c
 create mode 100644 src/probe_modules/module_icmp6_nmap_echo_2.c
 create mode 100644 src/probe_modules/module_icmp6_nmap_node_req.c
 create mode 100644 src/probe_modules/module_ipv6_nmap_tcp.c
 create mode 100644 src/probe_modules/module_ipv6_nmap_udp.c

diff --git a/capture.sh b/capture.sh
new file mode 100755
index 0000000..1da2a36
--- /dev/null
+++ b/capture.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+sudo tshark -V -f "src host fe80::1e69:7aff:fe60:7aa5" -P -o udp.check_checksum:TRUE -o tcp.check_checksum:TRUE
\ No newline at end of file
diff --git a/compile.sh b/compile.sh
new file mode 100755
index 0000000..76c63d1
--- /dev/null
+++ b/compile.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+cd build && sudo make install
diff --git a/ipv6.txt b/ipv6.txt
new file mode 100644
index 0000000..21c8db6
--- /dev/null
+++ b/ipv6.txt
@@ -0,0 +1 @@
+2001:0000:3238:DFE1:63:0000:0000:FEFB
diff --git a/run_zmap.sh b/run_zmap.sh
new file mode 100755
index 0000000..60acbe8
--- /dev/null
+++ b/run_zmap.sh
@@ -0,0 +1,4 @@
+#!/bin/bash
+./compile.sh
+wait
+sudo zmap -p 20023 -M $1 --ipv6-target-file=ipv6.txt --ipv6-source-ip=fe80::1e69:7aff:fe60:7aa5 --probe-args=$2
\ No newline at end of file
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index e8a179d..9a28945 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -44,6 +44,11 @@ set(PROBE_MODULE_SOURCES
     probe_modules/module_ipv6_udp.c
     probe_modules/module_ipv6_udp_dns.c
     probe_modules/module_icmp6_echoscan.c
+    probe_modules/module_icmp6_nmap_echo_1.c
+    probe_modules/module_icmp6_nmap_echo_2.c
+    probe_modules/module_icmp6_nmap_node_req.c
+    probe_modules/module_ipv6_nmap_tcp.c
+    probe_modules/module_ipv6_nmap_udp.c
 )
 
 set(SOURCES
diff --git a/src/probe_modules/module_icmp6_nmap_echo_1.c b/src/probe_modules/module_icmp6_nmap_echo_1.c
new file mode 100644
index 0000000..f342048
--- /dev/null
+++ b/src/probe_modules/module_icmp6_nmap_echo_1.c
@@ -0,0 +1,210 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP echo request (ping) scans
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp6_nmap_echo_1;
+
+int icmp6_nmap_echo_1_global_initialize(struct state_conf *conf)
+{
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_icmp6_nmap_echo_1.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_echo_1.pcap_filter, conf->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_1_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+
+    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
+	// ICMPv6 header plus 8 bytes of data (validation)
+	uint16_t payload_len = sizeof(struct icmp6_hdr) + 120;
+    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
+
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	make_icmp6_header(icmp6_header);
+
+	char *payload = (char *)(&icmp6_header[1]);
+	memset(payload, 0x00, 120);
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_1_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, UNUSED int probe_num, UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	
+	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
+
+	// // Include validation in ICMPv6 payload data
+	// icmp6_header->icmp6_data32[1] = validation[0];
+	// icmp6_header->icmp6_data32[2] = validation[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	icmp6_header->icmp6_code = 9;
+	icmp6_header->icmp6_id= htons(999);
+	icmp6_header->icmp6_seq = htons(295);
+
+	icmp6_header->icmp6_cksum = 0;
+	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
+                &ip6_header->ip6_src,
+		        &ip6_header->ip6_dst,
+				icmp6_header,
+				120
+                );
+
+	// ip6_header->ip6_ctlun.ip6_un1.ip6_un1_flow = 0;
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp6_nmap_echo_1_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
+
+	fprintf(fp, "icmp { type: %u | code: %u "
+			"| checksum: %#04X | id: %u | seq: %u }\n",
+			icmp6_header->icmp6_type,
+			icmp6_header->icmp6_code,
+			ntohs(icmp6_header->icmp6_cksum),
+			ntohs(icmp6_header->icmp6_id),
+			ntohs(icmp6_header->icmp6_seq)
+		);
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+
+static int icmp6_validate_packet(const struct ip *ip_hdr,
+		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
+{
+    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
+
+	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
+		return 0;
+	}
+
+    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
+	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
+		// buffer not large enough to contain expected icmp header
+		return 0;
+	}
+
+    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
+	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
+
+	return 1;
+
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
+        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
+
+        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
+        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
+			return 0;
+		}
+
+		// Use inner headers for validation
+		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
+		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
+
+		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
+        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
+			     (uint8_t *) validation);
+	}
+	// validate icmp id
+	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+
+	// Validate ICMPv6 data
+	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void icmp6_nmap_echo_1_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+	{.name="type", .type="int", .desc="icmp message type"},
+	{.name="code", .type="int", .desc="icmp message sub type code"},
+	{.name="icmp-id", .type="int", .desc="icmp id number"},
+	{.name="seq", .type="int", .desc="icmp sequence number"},
+    {.name="classification", .type="string", .desc="probe module classification"},
+	{.name="success", .type="int", .desc="did probe module classify response as success"}
+};
+
+
+probe_module_t module_icmp6_nmap_echo_1 = {
+	.name = "icmp6_nmap_echo_1",
+	.packet_length = 182, // 14 Eth + 40 IPv6 + 8 ICMP6 + 120
+	.pcap_filter = "icmp6", // and icmp6[0]=!8",
+	.pcap_snaplen =  500,
+	.port_args = 1,
+	.global_initialize = &icmp6_nmap_echo_1_global_initialize,
+	.thread_initialize = &icmp6_nmap_echo_1_init_perthread,
+	.make_packet = &icmp6_nmap_echo_1_make_packet,
+	.print_packet = &icmp6_nmap_echo_1_print_packet,
+	.process_packet = &icmp6_nmap_echo_1_process_packet,
+	.validate_packet = &icmp6_validate_packet,
+	.close = NULL,
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 7};
+
diff --git a/src/probe_modules/module_icmp6_nmap_echo_2.c b/src/probe_modules/module_icmp6_nmap_echo_2.c
new file mode 100644
index 0000000..eb8fbb3
--- /dev/null
+++ b/src/probe_modules/module_icmp6_nmap_echo_2.c
@@ -0,0 +1,212 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP echo request (ping) scans
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp6_nmap_echo_2;
+
+int icmp6_nmap_echo_2_global_initialize(struct state_conf *conf)
+{
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_icmp6_nmap_echo_2.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_echo_2.pcap_filter, conf->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_2_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+
+    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
+	// ICMPv6 header plus 8 bytes of data (validation)
+	uint16_t payload_len = sizeof(struct icmp6_hdr) + 150; // includes extra bits for validation
+    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
+
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	make_icmp6_header(icmp6_header);
+
+	char *payload = (char *)(&icmp6_header[1]);
+	memset(payload, 0x00, 150);
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_echo_2_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, UNUSED int probe_num, UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	
+	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
+
+	// // Include validation in ICMPv6 payload data
+	// icmp6_header->icmp6_data32[1] = validation[0];
+	// icmp6_header->icmp6_data32[2] = validation[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	// icmp6_header->icmp6_id= icmp_idnum;
+
+
+	icmp6_header->icmp6_id = htons(1000);
+	icmp6_header->icmp6_seq = htons(296);
+
+	// TODO: add sensible TOS value
+
+	icmp6_header->icmp6_cksum = 0;
+	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
+                &ip6_header->ip6_src,
+		        &ip6_header->ip6_dst,
+				icmp6_header,
+				150
+                );
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp6_nmap_echo_2_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
+
+	fprintf(fp, "icmp { type: %u | code: %u "
+			"| checksum: %#04X | id: %u | seq: %u }\n",
+			icmp6_header->icmp6_type,
+			icmp6_header->icmp6_code,
+			ntohs(icmp6_header->icmp6_cksum),
+			ntohs(icmp6_header->icmp6_id),
+			ntohs(icmp6_header->icmp6_seq)
+		);
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+
+static int icmp6_validate_packet(const struct ip *ip_hdr,
+		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
+{
+    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
+
+	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
+		return 0;
+	}
+
+    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
+	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
+		// buffer not large enough to contain expected icmp header
+		return 0;
+	}
+
+    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
+	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
+
+	return 1;
+
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
+        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
+
+        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
+        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
+			return 0;
+		}
+
+		// Use inner headers for validation
+		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
+		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
+
+		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
+        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
+			     (uint8_t *) validation);
+	}
+	// validate icmp id
+	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+
+	// Validate ICMPv6 data
+	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void icmp6_nmap_echo_2_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+	{.name="type", .type="int", .desc="icmp message type"},
+	{.name="code", .type="int", .desc="icmp message sub type code"},
+	{.name="icmp-id", .type="int", .desc="icmp id number"},
+	{.name="seq", .type="int", .desc="icmp sequence number"},
+    {.name="classification", .type="string", .desc="probe module classification"},
+	{.name="success", .type="int", .desc="did probe module classify response as success"}
+};
+
+
+probe_module_t module_icmp6_nmap_echo_2 = {
+	.name = "icmp6_nmap_echo_2",
+	.packet_length = 212, // 62, // ICMPv4: 64 bit --> Why 62? ICMPv6 also 64 bit --> Leave 64
+	.pcap_filter = "icmp6",
+	.pcap_snaplen = 300, // 14 ethernet header + 40 IPv6 header + 8 ICMPv6 header + 40 inner IPv6 header + 8 inner ICMPv6 header + 8 payload
+	.port_args = 1,
+	.global_initialize = &icmp6_nmap_echo_2_global_initialize,
+	.thread_initialize = &icmp6_nmap_echo_2_init_perthread,
+	.make_packet = &icmp6_nmap_echo_2_make_packet,
+	.print_packet = &icmp6_nmap_echo_2_print_packet,
+	.process_packet = &icmp6_nmap_echo_2_process_packet,
+	.validate_packet = &icmp6_validate_packet,
+	.close = NULL,
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 7};
+
diff --git a/src/probe_modules/module_icmp6_nmap_node_req.c b/src/probe_modules/module_icmp6_nmap_node_req.c
new file mode 100644
index 0000000..2e5feae
--- /dev/null
+++ b/src/probe_modules/module_icmp6_nmap_node_req.c
@@ -0,0 +1,211 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP echo request (ping) scans
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp6_nmap_node_req;
+
+int icmp6_nmap_node_req_global_initialize(struct state_conf *conf)
+{
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_icmp6_nmap_node_req.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_node_req.pcap_filter, conf->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_node_req_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+
+    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
+	uint16_t payload_len = sizeof(struct icmp6_hdr) + 8 + 16; // nonce + requested IP
+    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
+
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	make_icmp6_header(icmp6_header); // unnecessary?
+	char *payload = (char *)(&icmp6_header[1]);
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp6_nmap_node_req_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
+	
+	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
+
+	// // Include validation in ICMPv6 payload data
+	// icmp6_header->icmp6_data32[1] = validation[0];
+	// icmp6_header->icmp6_data32[2] = validation[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	icmp6_header->icmp6_type = 139;
+	icmp6_header->icmp6_code = 0;
+
+	icmp6_header->icmp6_data16[0] = htons(4);
+	icmp6_header->icmp6_data16[1] = htons(2);
+
+	struct in6_addr* data = &icmp6_header[2];
+	*data = ip6_header->ip6_dst;
+
+		// icmp6_header->icmp6_id= icmp_idnum;
+	icmp6_header->icmp6_cksum = 0;
+	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
+                &ip6_header->ip6_src,
+		        &ip6_header->ip6_dst,
+				icmp6_header,
+				16+8
+                );
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp6_nmap_node_req_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
+
+	fprintf(fp, "icmp { type: %u | code: %u "
+			"| checksum: %#04X | id: %u | seq: %u }\n",
+			icmp6_header->icmp6_type,
+			icmp6_header->icmp6_code,
+			ntohs(icmp6_header->icmp6_cksum),
+			ntohs(icmp6_header->icmp6_id),
+			ntohs(icmp6_header->icmp6_seq)
+		);
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+
+static int icmp6_nmap_node_req_validate_packet(const struct ip *ip_hdr,
+		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
+{
+    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
+
+	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
+		return 0;
+	}
+
+    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
+	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
+		// buffer not large enough to contain expected icmp header
+		return 0;
+	}
+
+    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
+	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
+
+	return 1;
+
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
+        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
+
+        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
+        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
+			return 0;
+		}
+
+		// Use inner headers for validation
+		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
+		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
+
+		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
+        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
+			     (uint8_t *) validation);
+	}
+	// validate icmp id
+	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+
+	// Validate ICMPv6 data
+	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void icmp6_nmap_node_req_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+	{.name="type", .type="int", .desc="icmp message type"},
+	{.name="code", .type="int", .desc="icmp message sub type code"},
+	{.name="icmp-id", .type="int", .desc="icmp id number"},
+	{.name="seq", .type="int", .desc="icmp sequence number"},
+    {.name="classification", .type="string", .desc="probe module classification"},
+	{.name="success", .type="int", .desc="did probe module classify response as success"}
+};
+
+
+probe_module_t module_icmp6_nmap_node_req = {
+	.name = "icmp6_nmap_node_req",
+	.packet_length = 86,
+	.pcap_filter = "icmp6", // and icmp6[0]=!8",
+	.pcap_snaplen =  500, // 14 ethernet header + 40 IPv6 header + 8 ICMPv6 header + 40 inner IPv6 header + 8 inner ICMPv6 header + 8 payload
+	.port_args = 1,
+	.global_initialize = &icmp6_nmap_node_req_global_initialize,
+	.thread_initialize = &icmp6_nmap_node_req_init_perthread,
+	.make_packet = &icmp6_nmap_node_req_make_packet,
+	.print_packet = &icmp6_nmap_node_req_print_packet,
+	.process_packet = &icmp6_nmap_node_req_process_packet,
+	.validate_packet = &icmp6_nmap_node_req_validate_packet,
+	.close = NULL,
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 7};
+
diff --git a/src/probe_modules/module_ipv6_nmap_tcp.c b/src/probe_modules/module_ipv6_nmap_tcp.c
new file mode 100644
index 0000000..72c6aa9
--- /dev/null
+++ b/src/probe_modules/module_ipv6_nmap_tcp.c
@@ -0,0 +1,218 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing TCP SYN scans over IPv6
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../fieldset.h"
+#include "probe_modules.h"
+#include "packet.h"
+
+probe_module_t module_ipv6_nmap_tcp;
+static char* packet_type = NULL;
+static uint32_t num_ports;
+
+int ipv6_nmap_tcp_global_initialize(struct state_conf *state)
+{
+	num_ports = state->source_port_last - state->source_port_first + 1;
+
+	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
+	if (asprintf((char ** restrict) &module_ipv6_nmap_tcp.pcap_filter, "%s && ip6 dst host %s", module_ipv6_nmap_tcp.pcap_filter, state->ipv6_source_ip) == -1) {
+		return 1;
+	}
+
+    if(state->probe_args)
+    {
+        char *probe_args = state->probe_args;
+        if(strcmp(probe_args, "t5") == 0) 
+        {
+            packet_type = strdup(probe_args);
+        }
+        else if(strcmp(probe_args, "t6") == 0) 
+        {
+            packet_type = strdup(probe_args);
+        }
+        else if(strcmp(probe_args, "t7") == 0)
+        {
+            packet_type = strdup(probe_args);
+        }
+        else
+        {
+            printf("Invalid probe argument: options are: {t5 t6 t7}\n");
+            return EXIT_FAILURE;
+        }
+    }
+    else
+    {
+        packet_type = strdup("t5"); 
+    }
+
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_tcp_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, port_h_t dst_port,
+		__attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+	struct ip6_hdr *ip6_header = (struct ip6_hdr*)(&eth_header[1]);
+	uint16_t payload_len = 40; // 20 TCP + 20 TCP Options
+	make_ip6_header(ip6_header, IPPROTO_TCP, payload_len);
+	struct tcphdr *tcp_header = (struct tcphdr*)(&ip6_header[1]);
+	make_tcp_header(tcp_header, dst_port, TH_SYN);
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_tcp_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip, UNUSED ipaddr_n_t dst_ip,
+        uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr*) (&eth_header[1]);
+	struct tcphdr *tcp_header = (struct tcphdr*) (&ip6_header[1]);
+	void *tcp_options = (void *)(&tcp_header[1]);
+	uint32_t tcp_seq = validation[0];
+	uint8_t *tcp_opts;
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+
+	tcp_header->th_sport = htons(get_src_port(num_ports,
+				probe_num, validation));
+	tcp_header->th_seq = 100;
+	tcp_header->th_off = 10;
+
+	if(strcmp(packet_type, "t5") == 0)
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(31337);
+        tcp_header->th_flags = TH_SYN;
+    }
+    else if(strcmp(packet_type, "t6") == 0)
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(32768);
+		// ip_header->ip_off = htons(IP_DF); IPv6 only fragments at end
+        tcp_header->th_flags = TH_ACK;
+    }
+    else
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0F\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(65535);
+        tcp_header->th_flags = (TH_FIN | TH_PUSH | TH_URG);
+    }
+
+	memcpy(tcp_options, tcp_opts, 20);
+
+	tcp_header->th_sum = tcp6_checksum(2*sizeof(struct tcphdr),
+			&ip6_header->ip6_src, &ip6_header->ip6_dst, tcp_header);
+
+	return EXIT_SUCCESS;
+}
+
+void ipv6_nmap_tcp_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct tcphdr *tcph = (struct tcphdr *) &iph[1];
+	fprintf(fp, "tcp { source: %u | dest: %u | seq: %u | checksum: %#04X }\n",
+			ntohs(tcph->th_sport),
+			ntohs(tcph->th_dport),
+			ntohl(tcph->th_seq),
+			ntohs(tcph->th_sum));
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+int ipv6_nmap_tcp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+		__attribute__((unused))uint32_t *src_ip,
+		uint32_t *validation)
+{
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) ip_hdr;
+
+	if (ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_TCP) {
+		return 0;
+	}
+	if ((ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen)) > len) {
+		// buffer not large enough to contain expected tcp header, i.e. IPv6 payload
+		return 0;
+	}
+	struct tcphdr *tcp_hdr = (struct tcphdr*) (&ipv6_hdr[1]);
+	uint16_t sport = tcp_hdr->th_sport;
+	uint16_t dport = tcp_hdr->th_dport;
+	// validate source port
+	if (ntohs(sport) != zconf.target_port) {
+		return 0;
+	}
+	// validate destination port
+	if (!check_dst_port(ntohs(dport), num_ports, validation)) {
+		return 0;
+	}
+	// validate tcp acknowledgement number
+	if (htonl(tcp_hdr->th_ack) != htonl(validation[0])+1) {
+		return 0;
+	}
+	return 1;
+}
+
+void ipv6_nmap_tcp_process_packet(const u_char *packet,
+		__attribute__((unused)) uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ether_header *eth_hdr = (struct ether_header *) packet;
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) (&eth_hdr[1]);
+	// struct tcphdr *tcp_hdr = (struct tcphdr*) (&ipv6_hdr[1]);
+	uint32_t packet_size = htons(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
+	{.name = "sport",  .type = "int", .desc = "TCP source port"},
+	{.name = "dport",  .type = "int", .desc = "TCP destination port"},
+	{.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
+	{.name = "classification", .type="string", .desc = "packet classification"},
+	{.name = "success", .type="int", .desc = "is response considered success"}
+};
+
+probe_module_t module_ipv6_nmap_tcp = {
+	.name = "ipv6_nmap_tcp",
+	.packet_length = 94, // 14 Ethernet + 40 IPv6 + 20 TCP + 20 Options
+	.pcap_filter = "ip6 proto 6",
+	.pcap_snaplen = 116, // was 96 for IPv4
+	.port_args = 1,
+	.global_initialize = &ipv6_nmap_tcp_global_initialize,
+	.thread_initialize = &ipv6_nmap_tcp_init_perthread,
+	.make_packet = &ipv6_nmap_tcp_make_packet,
+	.print_packet = &ipv6_nmap_tcp_print_packet,
+	.process_packet = &ipv6_nmap_tcp_process_packet,
+	.validate_packet = &ipv6_nmap_tcp_validate_packet,
+	.close = NULL,
+	.helptext = "Probe module that implements nmap closed port probes",
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 6};
+
diff --git a/src/probe_modules/module_ipv6_nmap_udp.c b/src/probe_modules/module_ipv6_nmap_udp.c
new file mode 100644
index 0000000..2cda6a0
--- /dev/null
+++ b/src/probe_modules/module_ipv6_nmap_udp.c
@@ -0,0 +1,154 @@
+/*
+ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
+ * Technical University of Munich
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing arbitrary UDP scans over IPv6
+
+// Needed for asprintf
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../../lib/xalloc.h"
+#include "../../lib/lockfd.h"
+#include "logger.h"
+#include "probe_modules.h"
+#include "packet.h"
+#include "aesrand.h"
+#include "state.h"
+#include "module_udp.h"
+
+#define ICMP_UNREACH_HEADER_SIZE 8
+
+static int num_ports;
+
+probe_module_t module_ipv6_nmap_udp;
+
+int ipv6_nmap_udp_global_initialize(struct state_conf *conf) {
+	num_ports = conf->source_port_last - conf->source_port_first + 1;
+
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_udp_init_perthread(void* buf, macaddr_t *src,
+		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,\
+		void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
+	struct ip6_hdr *ipv6_header = (struct ip6_hdr*)(&eth_header[1]);
+	uint16_t payload_len = 308; // 8 UDP + 300 Payload. htons is called by make_ip6_header
+	make_ip6_header(ipv6_header, IPPROTO_UDP, payload_len);
+
+	struct udphdr *udp_header = (struct udphdr*)(&ipv6_header[1]);
+	make_udp_header(udp_header, zconf.target_port, payload_len);
+
+	char* payload = (char*)(&udp_header[1]);
+	memset(payload, 0x43, 300);
+
+	return EXIT_SUCCESS;
+}
+
+int ipv6_nmap_udp_make_packet(void *buf, UNUSED size_t *buf_len, __attribute__((unused)) ipaddr_n_t src_ip,
+		__attribute__((unused)) ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
+{
+	// From module_ipv6_nmap_udp_dns
+	struct ether_header *eth_header = (struct ether_header *) buf;
+	struct ip6_hdr *ip6_header = (struct ip6_hdr*) (&eth_header[1]);
+	struct udphdr *udp_header= (struct udphdr *) &ip6_header[1];
+
+	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
+	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
+	// ip_header->ip_id = htons(0x1042); doesn't exist in IPv6
+	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
+	udp_header->uh_sport = htons(43213);
+
+	udp_header->uh_sum = ipv6_udp_checksum(&ip6_header->ip6_src, &ip6_header->ip6_dst, udp_header);
+
+	return EXIT_SUCCESS;
+}
+
+void ipv6_nmap_udp_print_packet(FILE *fp, void* packet)
+{
+	struct ether_header *ethh = (struct ether_header *) packet;
+	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
+	struct udphdr *udph  = (struct udphdr*) &iph[1];
+	fprintf(fp, "udp { source: %u | dest: %u | checksum: %#04X }\n",
+		ntohs(udph->uh_sport),
+		ntohs(udph->uh_dport),
+		ntohs(udph->uh_sum));
+	fprintf_ipv6_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+void ipv6_nmap_udp_process_packet(const u_char *packet, UNUSED uint32_t len, fieldset_t *fs,
+		__attribute__((unused)) uint32_t *validation)
+{
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
+	uint32_t packet_size = ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
+
+	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+
+int ipv6_nmap_udp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+		UNUSED uint32_t *src_ip, uint32_t *validation)
+{
+	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) ip_hdr;
+
+	if (ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_UDP) {
+		return 0;
+	}
+
+	if ((ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen)) > len) {
+		// buffer not large enough to contain expected UDP header, i.e. IPv6 payload
+		return 0;
+	}
+	if (!ipv6_udp_validate_packet(ipv6_hdr, len, NULL, validation)) {
+		return 0;
+	}
+	return 1;
+}
+
+static fielddef_t fields[] = {
+	{.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
+	{.name = "sport", .type = "int", .desc = "UDP source port"},
+	{.name = "dport", .type = "int", .desc = "UDP destination port"},
+	{.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
+	{.name = "classification", .type="string", .desc = "packet classification"},
+	{.name = "success", .type="int", .desc = "is response considered success"},
+};
+
+probe_module_t module_ipv6_nmap_udp = {
+	.name = "ipv6_nmap_udp",
+	.packet_length = 362, // 14 Ethernet, 40 IPv6, 8 UDP, 300 Payload
+	.pcap_filter = "ip6 proto 17",
+	.pcap_snaplen = 1500,
+	.port_args = 1,
+	.thread_initialize = &ipv6_nmap_udp_init_perthread,
+	.global_initialize = &ipv6_nmap_udp_global_initialize,
+	.make_packet = &ipv6_nmap_udp_make_packet,
+	.print_packet = &ipv6_nmap_udp_print_packet,
+	.validate_packet = &ipv6_nmap_udp_validate_packet,
+	.process_packet = &ipv6_nmap_udp_process_packet,
+	.close = NULL,
+	.helptext = "Probe module that implements nmap closed port probes",
+	.output_type = OUTPUT_TYPE_STATIC,
+	.fields = fields,
+	.numfields = 6};
diff --git a/src/probe_modules/module_ipv6_udp.c b/src/probe_modules/module_ipv6_udp.c
index cdd8fb4..9cd2f39 100644
--- a/src/probe_modules/module_ipv6_udp.c
+++ b/src/probe_modules/module_ipv6_udp.c
@@ -119,6 +119,8 @@ int ipv6_udp_global_initialize(struct state_conf *conf) {
 
 	FILE *inp;
 
+	log_info("udp", "ASFDSAFDASFADS HI");
+
 	num_ports = conf->source_port_last - conf->source_port_first + 1;
 	udp_set_num_ports(num_ports);
 
diff --git a/src/probe_modules/probe_modules.c b/src/probe_modules/probe_modules.c
index 1562086..15fc39f 100644
--- a/src/probe_modules/probe_modules.c
+++ b/src/probe_modules/probe_modules.c
@@ -35,6 +35,11 @@ extern probe_module_t module_ipv6_tcp_synopt;
 extern probe_module_t module_ipv6_udp;
 extern probe_module_t module_ipv6_udp_dns;
 extern probe_module_t module_icmp6_echoscan;
+extern probe_module_t module_icmp6_nmap_echo_1;
+extern probe_module_t module_icmp6_nmap_echo_2;
+extern probe_module_t module_icmp6_nmap_node_req;
+extern probe_module_t module_ipv6_nmap_tcp;
+extern probe_module_t module_ipv6_nmap_udp;
 
 // ADD YOUR MODULE HERE
 
@@ -54,7 +59,12 @@ probe_module_t* probe_modules[] = {
 	&module_ipv6_tcp_synopt,
 	&module_ipv6_udp,
 	&module_ipv6_udp_dns,
-	&module_icmp6_echoscan
+	&module_icmp6_echoscan,
+	&module_icmp6_nmap_echo_1,
+	&module_icmp6_nmap_echo_2,
+	&module_icmp6_nmap_node_req,
+	&module_ipv6_nmap_tcp,
+	&module_ipv6_nmap_udp
 	// ADD YOUR MODULE HERE
 };
 
-- 
2.20.1


From b6992ca4cdc378ec63ed6f011fb17f3a9b969884 Mon Sep 17 00:00:00 2001
From: Ross Teixeira <rapt@cs.princeton.edu>
Date: Wed, 18 Mar 2020 06:03:33 +0000
Subject: [PATCH 2/3] merged repos

---
 ipv6_changes.patch                          | 1162 +++++++++++++++++++
 src/CMakeLists.txt                          |    6 +
 src/probe_modules/module_icmp_echo.c        |   42 +-
 src/probe_modules/module_icmp_reply.c       |  219 ++++
 src/probe_modules/module_icmp_timestamp.c   |  154 +++
 src/probe_modules/module_nmap_icmp_echo_1.c |  190 +++
 src/probe_modules/module_nmap_icmp_echo_2.c |  189 +++
 src/probe_modules/module_nmap_tcp.c         |  211 ++++
 src/probe_modules/module_nmap_tcp.h         |   42 +
 src/probe_modules/module_nmap_udp.c         |  200 ++++
 src/probe_modules/module_nmap_udp.h         |   42 +
 src/probe_modules/probe_modules.c           |   15 +
 12 files changed, 2438 insertions(+), 34 deletions(-)
 create mode 100644 ipv6_changes.patch
 create mode 100644 src/probe_modules/module_icmp_reply.c
 create mode 100644 src/probe_modules/module_icmp_timestamp.c
 create mode 100644 src/probe_modules/module_nmap_icmp_echo_1.c
 create mode 100644 src/probe_modules/module_nmap_icmp_echo_2.c
 create mode 100644 src/probe_modules/module_nmap_tcp.c
 create mode 100644 src/probe_modules/module_nmap_tcp.h
 create mode 100644 src/probe_modules/module_nmap_udp.c
 create mode 100644 src/probe_modules/module_nmap_udp.h

diff --git a/ipv6_changes.patch b/ipv6_changes.patch
new file mode 100644
index 0000000..87d4fb9
--- /dev/null
+++ b/ipv6_changes.patch
@@ -0,0 +1,1162 @@
+From 3551224099ee15b3f84dc710bd31d8e5907bd88d Mon Sep 17 00:00:00 2001
+From: Ross Teixeira <rapt@cs.princeton.edu>
+Date: Wed, 18 Mar 2020 05:50:27 +0000
+Subject: [PATCH 1/1] ipv6 changes
+
+---
+ capture.sh                                    |   3 +
+ compile.sh                                    |   2 +
+ ipv6.txt                                      |   1 +
+ run_zmap.sh                                   |   4 +
+ src/CMakeLists.txt                            |   5 +
+ src/probe_modules/module_icmp6_nmap_echo_1.c  | 210 +++++++++++++++++
+ src/probe_modules/module_icmp6_nmap_echo_2.c  | 212 +++++++++++++++++
+ .../module_icmp6_nmap_node_req.c              | 211 +++++++++++++++++
+ src/probe_modules/module_ipv6_nmap_tcp.c      | 218 ++++++++++++++++++
+ src/probe_modules/module_ipv6_nmap_udp.c      | 154 +++++++++++++
+ src/probe_modules/module_ipv6_udp.c           |   2 +
+ src/probe_modules/probe_modules.c             |  12 +-
+ 12 files changed, 1033 insertions(+), 1 deletion(-)
+ create mode 100755 capture.sh
+ create mode 100755 compile.sh
+ create mode 100644 ipv6.txt
+ create mode 100755 run_zmap.sh
+ create mode 100644 src/probe_modules/module_icmp6_nmap_echo_1.c
+ create mode 100644 src/probe_modules/module_icmp6_nmap_echo_2.c
+ create mode 100644 src/probe_modules/module_icmp6_nmap_node_req.c
+ create mode 100644 src/probe_modules/module_ipv6_nmap_tcp.c
+ create mode 100644 src/probe_modules/module_ipv6_nmap_udp.c
+
+diff --git a/capture.sh b/capture.sh
+new file mode 100755
+index 0000000..1da2a36
+--- /dev/null
++++ b/capture.sh
+@@ -0,0 +1,3 @@
++#!/bin/bash
++
++sudo tshark -V -f "src host fe80::1e69:7aff:fe60:7aa5" -P -o udp.check_checksum:TRUE -o tcp.check_checksum:TRUE
+\ No newline at end of file
+diff --git a/compile.sh b/compile.sh
+new file mode 100755
+index 0000000..76c63d1
+--- /dev/null
++++ b/compile.sh
+@@ -0,0 +1,2 @@
++#!/bin/bash
++cd build && sudo make install
+diff --git a/ipv6.txt b/ipv6.txt
+new file mode 100644
+index 0000000..21c8db6
+--- /dev/null
++++ b/ipv6.txt
+@@ -0,0 +1 @@
++2001:0000:3238:DFE1:63:0000:0000:FEFB
+diff --git a/run_zmap.sh b/run_zmap.sh
+new file mode 100755
+index 0000000..60acbe8
+--- /dev/null
++++ b/run_zmap.sh
+@@ -0,0 +1,4 @@
++#!/bin/bash
++./compile.sh
++wait
++sudo zmap -p 20023 -M $1 --ipv6-target-file=ipv6.txt --ipv6-source-ip=fe80::1e69:7aff:fe60:7aa5 --probe-args=$2
+\ No newline at end of file
+diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
+index e8a179d..9a28945 100644
+--- a/src/CMakeLists.txt
++++ b/src/CMakeLists.txt
+@@ -44,6 +44,11 @@ set(PROBE_MODULE_SOURCES
+     probe_modules/module_ipv6_udp.c
+     probe_modules/module_ipv6_udp_dns.c
+     probe_modules/module_icmp6_echoscan.c
++    probe_modules/module_icmp6_nmap_echo_1.c
++    probe_modules/module_icmp6_nmap_echo_2.c
++    probe_modules/module_icmp6_nmap_node_req.c
++    probe_modules/module_ipv6_nmap_tcp.c
++    probe_modules/module_ipv6_nmap_udp.c
+ )
+ 
+ set(SOURCES
+diff --git a/src/probe_modules/module_icmp6_nmap_echo_1.c b/src/probe_modules/module_icmp6_nmap_echo_1.c
+new file mode 100644
+index 0000000..f342048
+--- /dev/null
++++ b/src/probe_modules/module_icmp6_nmap_echo_1.c
+@@ -0,0 +1,210 @@
++/*
++ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
++ * Technical University of Munich
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
++ * use this file except in compliance with the License. You may obtain a copy
++ * of the License at http://www.apache.org/licenses/LICENSE-2.0
++ */
++
++// probe module for performing ICMP echo request (ping) scans
++
++// Needed for asprintf
++#ifndef _GNU_SOURCE
++#define _GNU_SOURCE 1
++#endif
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <stdint.h>
++#include <time.h>
++#include <unistd.h>
++#include <string.h>
++
++#include "../../lib/includes.h"
++#include "probe_modules.h"
++#include "../fieldset.h"
++#include "packet.h"
++#include "validate.h"
++
++#define ICMP_SMALLEST_SIZE 5
++#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
++
++probe_module_t module_icmp6_nmap_echo_1;
++
++int icmp6_nmap_echo_1_global_initialize(struct state_conf *conf)
++{
++	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
++	if (asprintf((char ** restrict) &module_icmp6_nmap_echo_1.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_echo_1.pcap_filter, conf->ipv6_source_ip) == -1) {
++		return 1;
++	}
++
++	return EXIT_SUCCESS;
++}
++
++static int icmp6_nmap_echo_1_init_perthread(void* buf, macaddr_t *src,
++		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
++		__attribute__((unused)) void **arg_ptr)
++{
++	memset(buf, 0, MAX_PACKET_SIZE);
++
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
++
++    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
++	// ICMPv6 header plus 8 bytes of data (validation)
++	uint16_t payload_len = sizeof(struct icmp6_hdr) + 120;
++    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
++
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
++	make_icmp6_header(icmp6_header);
++
++	char *payload = (char *)(&icmp6_header[1]);
++	memset(payload, 0x00, 120);
++
++	return EXIT_SUCCESS;
++}
++
++static int icmp6_nmap_echo_1_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, UNUSED int probe_num, UNUSED void *arg)
++{
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
++	
++	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
++
++	// // Include validation in ICMPv6 payload data
++	// icmp6_header->icmp6_data32[1] = validation[0];
++	// icmp6_header->icmp6_data32[2] = validation[1];
++
++	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
++	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
++	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
++
++	icmp6_header->icmp6_code = 9;
++	icmp6_header->icmp6_id= htons(999);
++	icmp6_header->icmp6_seq = htons(295);
++
++	icmp6_header->icmp6_cksum = 0;
++	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
++                &ip6_header->ip6_src,
++		        &ip6_header->ip6_dst,
++				icmp6_header,
++				120
++                );
++
++	// ip6_header->ip6_ctlun.ip6_un1.ip6_un1_flow = 0;
++
++	return EXIT_SUCCESS;
++}
++
++static void icmp6_nmap_echo_1_print_packet(FILE *fp, void* packet)
++{
++	struct ether_header *ethh = (struct ether_header *) packet;
++	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
++
++	fprintf(fp, "icmp { type: %u | code: %u "
++			"| checksum: %#04X | id: %u | seq: %u }\n",
++			icmp6_header->icmp6_type,
++			icmp6_header->icmp6_code,
++			ntohs(icmp6_header->icmp6_cksum),
++			ntohs(icmp6_header->icmp6_id),
++			ntohs(icmp6_header->icmp6_seq)
++		);
++	fprintf_ipv6_header(fp, iph);
++	fprintf_eth_header(fp, ethh);
++	fprintf(fp, "------------------------------------------------------\n");
++}
++
++
++static int icmp6_validate_packet(const struct ip *ip_hdr,
++		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
++{
++    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
++
++	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
++		return 0;
++	}
++
++    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
++	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
++		// buffer not large enough to contain expected icmp header
++		return 0;
++	}
++
++    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
++	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
++
++	return 1;
++
++	// ICMP validation is tricky: for some packet types, we must look inside
++	// the payload
++	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
++        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
++
++        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
++        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
++			return 0;
++		}
++
++		// Use inner headers for validation
++		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
++		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
++
++		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
++        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
++			     (uint8_t *) validation);
++	}
++	// validate icmp id
++	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
++		return 0;
++	}
++
++	// Validate ICMPv6 data
++	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
++		return 0;
++	}
++
++	return 1;
++}
++
++static void icmp6_nmap_echo_1_process_packet(const u_char *packet,
++		__attribute__((unused)) uint32_t len, fieldset_t *fs,
++		__attribute__((unused)) uint32_t *validation)
++{
++	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
++	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
++
++	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
++    fs_add_bool(fs, "success", 1);
++}
++
++static fielddef_t fields[] = {
++	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
++	{.name="type", .type="int", .desc="icmp message type"},
++	{.name="code", .type="int", .desc="icmp message sub type code"},
++	{.name="icmp-id", .type="int", .desc="icmp id number"},
++	{.name="seq", .type="int", .desc="icmp sequence number"},
++    {.name="classification", .type="string", .desc="probe module classification"},
++	{.name="success", .type="int", .desc="did probe module classify response as success"}
++};
++
++
++probe_module_t module_icmp6_nmap_echo_1 = {
++	.name = "icmp6_nmap_echo_1",
++	.packet_length = 182, // 14 Eth + 40 IPv6 + 8 ICMP6 + 120
++	.pcap_filter = "icmp6", // and icmp6[0]=!8",
++	.pcap_snaplen =  500,
++	.port_args = 1,
++	.global_initialize = &icmp6_nmap_echo_1_global_initialize,
++	.thread_initialize = &icmp6_nmap_echo_1_init_perthread,
++	.make_packet = &icmp6_nmap_echo_1_make_packet,
++	.print_packet = &icmp6_nmap_echo_1_print_packet,
++	.process_packet = &icmp6_nmap_echo_1_process_packet,
++	.validate_packet = &icmp6_validate_packet,
++	.close = NULL,
++	.output_type = OUTPUT_TYPE_STATIC,
++	.fields = fields,
++	.numfields = 7};
++
+diff --git a/src/probe_modules/module_icmp6_nmap_echo_2.c b/src/probe_modules/module_icmp6_nmap_echo_2.c
+new file mode 100644
+index 0000000..eb8fbb3
+--- /dev/null
++++ b/src/probe_modules/module_icmp6_nmap_echo_2.c
+@@ -0,0 +1,212 @@
++/*
++ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
++ * Technical University of Munich
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
++ * use this file except in compliance with the License. You may obtain a copy
++ * of the License at http://www.apache.org/licenses/LICENSE-2.0
++ */
++
++// probe module for performing ICMP echo request (ping) scans
++
++// Needed for asprintf
++#ifndef _GNU_SOURCE
++#define _GNU_SOURCE 1
++#endif
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <stdint.h>
++#include <time.h>
++#include <unistd.h>
++#include <string.h>
++
++#include "../../lib/includes.h"
++#include "probe_modules.h"
++#include "../fieldset.h"
++#include "packet.h"
++#include "validate.h"
++
++#define ICMP_SMALLEST_SIZE 5
++#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
++
++probe_module_t module_icmp6_nmap_echo_2;
++
++int icmp6_nmap_echo_2_global_initialize(struct state_conf *conf)
++{
++	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
++	if (asprintf((char ** restrict) &module_icmp6_nmap_echo_2.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_echo_2.pcap_filter, conf->ipv6_source_ip) == -1) {
++		return 1;
++	}
++
++	return EXIT_SUCCESS;
++}
++
++static int icmp6_nmap_echo_2_init_perthread(void* buf, macaddr_t *src,
++		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
++		__attribute__((unused)) void **arg_ptr)
++{
++	memset(buf, 0, MAX_PACKET_SIZE);
++
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
++
++    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
++	// ICMPv6 header plus 8 bytes of data (validation)
++	uint16_t payload_len = sizeof(struct icmp6_hdr) + 150; // includes extra bits for validation
++    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
++
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
++	make_icmp6_header(icmp6_header);
++
++	char *payload = (char *)(&icmp6_header[1]);
++	memset(payload, 0x00, 150);
++
++	return EXIT_SUCCESS;
++}
++
++static int icmp6_nmap_echo_2_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, UNUSED int probe_num, UNUSED void *arg)
++{
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
++	
++	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
++
++	// // Include validation in ICMPv6 payload data
++	// icmp6_header->icmp6_data32[1] = validation[0];
++	// icmp6_header->icmp6_data32[2] = validation[1];
++
++	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
++	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
++	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
++
++	// icmp6_header->icmp6_id= icmp_idnum;
++
++
++	icmp6_header->icmp6_id = htons(1000);
++	icmp6_header->icmp6_seq = htons(296);
++
++	// TODO: add sensible TOS value
++
++	icmp6_header->icmp6_cksum = 0;
++	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
++                &ip6_header->ip6_src,
++		        &ip6_header->ip6_dst,
++				icmp6_header,
++				150
++                );
++
++	return EXIT_SUCCESS;
++}
++
++static void icmp6_nmap_echo_2_print_packet(FILE *fp, void* packet)
++{
++	struct ether_header *ethh = (struct ether_header *) packet;
++	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
++
++	fprintf(fp, "icmp { type: %u | code: %u "
++			"| checksum: %#04X | id: %u | seq: %u }\n",
++			icmp6_header->icmp6_type,
++			icmp6_header->icmp6_code,
++			ntohs(icmp6_header->icmp6_cksum),
++			ntohs(icmp6_header->icmp6_id),
++			ntohs(icmp6_header->icmp6_seq)
++		);
++	fprintf_ipv6_header(fp, iph);
++	fprintf_eth_header(fp, ethh);
++	fprintf(fp, "------------------------------------------------------\n");
++}
++
++
++static int icmp6_validate_packet(const struct ip *ip_hdr,
++		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
++{
++    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
++
++	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
++		return 0;
++	}
++
++    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
++	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
++		// buffer not large enough to contain expected icmp header
++		return 0;
++	}
++
++    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
++	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
++
++	return 1;
++
++	// ICMP validation is tricky: for some packet types, we must look inside
++	// the payload
++	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
++        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
++
++        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
++        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
++			return 0;
++		}
++
++		// Use inner headers for validation
++		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
++		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
++
++		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
++        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
++			     (uint8_t *) validation);
++	}
++	// validate icmp id
++	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
++		return 0;
++	}
++
++	// Validate ICMPv6 data
++	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
++		return 0;
++	}
++
++	return 1;
++}
++
++static void icmp6_nmap_echo_2_process_packet(const u_char *packet,
++		__attribute__((unused)) uint32_t len, fieldset_t *fs,
++		__attribute__((unused)) uint32_t *validation)
++{
++	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
++	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
++
++	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
++    fs_add_bool(fs, "success", 1);
++}
++
++static fielddef_t fields[] = {
++	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
++	{.name="type", .type="int", .desc="icmp message type"},
++	{.name="code", .type="int", .desc="icmp message sub type code"},
++	{.name="icmp-id", .type="int", .desc="icmp id number"},
++	{.name="seq", .type="int", .desc="icmp sequence number"},
++    {.name="classification", .type="string", .desc="probe module classification"},
++	{.name="success", .type="int", .desc="did probe module classify response as success"}
++};
++
++
++probe_module_t module_icmp6_nmap_echo_2 = {
++	.name = "icmp6_nmap_echo_2",
++	.packet_length = 212, // 62, // ICMPv4: 64 bit --> Why 62? ICMPv6 also 64 bit --> Leave 64
++	.pcap_filter = "icmp6",
++	.pcap_snaplen = 300, // 14 ethernet header + 40 IPv6 header + 8 ICMPv6 header + 40 inner IPv6 header + 8 inner ICMPv6 header + 8 payload
++	.port_args = 1,
++	.global_initialize = &icmp6_nmap_echo_2_global_initialize,
++	.thread_initialize = &icmp6_nmap_echo_2_init_perthread,
++	.make_packet = &icmp6_nmap_echo_2_make_packet,
++	.print_packet = &icmp6_nmap_echo_2_print_packet,
++	.process_packet = &icmp6_nmap_echo_2_process_packet,
++	.validate_packet = &icmp6_validate_packet,
++	.close = NULL,
++	.output_type = OUTPUT_TYPE_STATIC,
++	.fields = fields,
++	.numfields = 7};
++
+diff --git a/src/probe_modules/module_icmp6_nmap_node_req.c b/src/probe_modules/module_icmp6_nmap_node_req.c
+new file mode 100644
+index 0000000..2e5feae
+--- /dev/null
++++ b/src/probe_modules/module_icmp6_nmap_node_req.c
+@@ -0,0 +1,211 @@
++/*
++ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
++ * Technical University of Munich
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
++ * use this file except in compliance with the License. You may obtain a copy
++ * of the License at http://www.apache.org/licenses/LICENSE-2.0
++ */
++
++// probe module for performing ICMP echo request (ping) scans
++
++// Needed for asprintf
++#ifndef _GNU_SOURCE
++#define _GNU_SOURCE 1
++#endif
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <stdint.h>
++#include <time.h>
++#include <unistd.h>
++#include <string.h>
++
++#include "../../lib/includes.h"
++#include "probe_modules.h"
++#include "../fieldset.h"
++#include "packet.h"
++#include "validate.h"
++
++#define ICMP_SMALLEST_SIZE 5
++#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
++
++probe_module_t module_icmp6_nmap_node_req;
++
++int icmp6_nmap_node_req_global_initialize(struct state_conf *conf)
++{
++	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
++	if (asprintf((char ** restrict) &module_icmp6_nmap_node_req.pcap_filter, "%s && ip6 dst host %s", module_icmp6_nmap_node_req.pcap_filter, conf->ipv6_source_ip) == -1) {
++		return 1;
++	}
++
++	return EXIT_SUCCESS;
++}
++
++static int icmp6_nmap_node_req_init_perthread(void* buf, macaddr_t *src,
++		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,
++		__attribute__((unused)) void **arg_ptr)
++{
++	memset(buf, 0, MAX_PACKET_SIZE);
++
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
++
++    struct ip6_hdr *ip6_header = (struct ip6_hdr *) (&eth_header[1]);
++	uint16_t payload_len = sizeof(struct icmp6_hdr) + 8 + 16; // nonce + requested IP
++    make_ip6_header(ip6_header, IPPROTO_ICMPV6, payload_len);
++
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
++	make_icmp6_header(icmp6_header); // unnecessary?
++	char *payload = (char *)(&icmp6_header[1]);
++
++	return EXIT_SUCCESS;
++}
++
++static int icmp6_nmap_node_req_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip,  UNUSED ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
++{
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	struct ip6_hdr *ip6_header = (struct ip6_hdr *)(&eth_header[1]);
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*)(&ip6_header[1]);
++	
++	// uint16_t icmp_idnum = validation[2] & 0xFFFF;
++
++	// // Include validation in ICMPv6 payload data
++	// icmp6_header->icmp6_data32[1] = validation[0];
++	// icmp6_header->icmp6_data32[2] = validation[1];
++
++	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
++	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
++	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
++
++	icmp6_header->icmp6_type = 139;
++	icmp6_header->icmp6_code = 0;
++
++	icmp6_header->icmp6_data16[0] = htons(4);
++	icmp6_header->icmp6_data16[1] = htons(2);
++
++	struct in6_addr* data = &icmp6_header[2];
++	*data = ip6_header->ip6_dst;
++
++		// icmp6_header->icmp6_id= icmp_idnum;
++	icmp6_header->icmp6_cksum = 0;
++	icmp6_header->icmp6_cksum= (uint16_t) icmp6_checksum(
++                &ip6_header->ip6_src,
++		        &ip6_header->ip6_dst,
++				icmp6_header,
++				16+8
++                );
++
++	return EXIT_SUCCESS;
++}
++
++static void icmp6_nmap_node_req_print_packet(FILE *fp, void* packet)
++{
++	struct ether_header *ethh = (struct ether_header *) packet;
++	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
++	struct icmp6_hdr *icmp6_header = (struct icmp6_hdr*) (&iph[1]);
++
++	fprintf(fp, "icmp { type: %u | code: %u "
++			"| checksum: %#04X | id: %u | seq: %u }\n",
++			icmp6_header->icmp6_type,
++			icmp6_header->icmp6_code,
++			ntohs(icmp6_header->icmp6_cksum),
++			ntohs(icmp6_header->icmp6_id),
++			ntohs(icmp6_header->icmp6_seq)
++		);
++	fprintf_ipv6_header(fp, iph);
++	fprintf_eth_header(fp, ethh);
++	fprintf(fp, "------------------------------------------------------\n");
++}
++
++
++static int icmp6_nmap_node_req_validate_packet(const struct ip *ip_hdr,
++		uint32_t len, __attribute__((unused)) uint32_t *src_ip, uint32_t *validation)
++{
++    struct ip6_hdr *ip6_hdr = (struct ip6_hdr*) ip_hdr;
++
++	if (ip6_hdr->ip6_nxt != IPPROTO_ICMPV6) {
++		return 0;
++	}
++
++    // IPv6 header is fixed length at 40 bytes + ICMPv6 header + 8 bytes of ICMPv6 data
++	if ( ( sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) + 2 * sizeof(uint32_t)) > len) {
++		// buffer not large enough to contain expected icmp header
++		return 0;
++	}
++
++    // offset iphdr by ip header length of 40 bytes to shift pointer to ICMP6 header
++	struct icmp6_hdr *icmp6_h = (struct icmp6_hdr *) (&ip6_hdr[1]);
++
++	return 1;
++
++	// ICMP validation is tricky: for some packet types, we must look inside
++	// the payload
++	if (icmp6_h->icmp6_type == ICMP6_TIME_EXCEEDED || icmp6_h->icmp6_type == ICMP6_DST_UNREACH
++        || icmp6_h->icmp6_type == ICMP6_PACKET_TOO_BIG || icmp6_h->icmp6_type == ICMP6_PARAM_PROB) {
++
++        // IP6 + ICMP6 headers + inner headers + 8 byte payload (validation)
++        if (2*sizeof(struct ip6_hdr) + 2*sizeof(struct icmp6_hdr) + 2*sizeof(uint32_t) > len) {
++			return 0;
++		}
++
++		// Use inner headers for validation
++		ip6_hdr = (struct ip6_hdr *) &icmp6_h[1];
++		icmp6_h = (struct icmp6_hdr *) &ip6_hdr[1];
++
++		// Send original src and dst IP as data in ICMPv6 payload and regenerate the validation here
++        validate_gen_ipv6(&ip6_hdr->ip6_dst, &ip6_hdr->ip6_src,
++			     (uint8_t *) validation);
++	}
++	// validate icmp id
++	if (icmp6_h->icmp6_id != (validation[2] & 0xFFFF)) {
++		return 0;
++	}
++
++	// Validate ICMPv6 data
++	if (icmp6_h->icmp6_data32[1] != validation[0] || icmp6_h->icmp6_data32[2] != validation[1]) {
++		return 0;
++	}
++
++	return 1;
++}
++
++static void icmp6_nmap_node_req_process_packet(const u_char *packet,
++		__attribute__((unused)) uint32_t len, fieldset_t *fs,
++		__attribute__((unused)) uint32_t *validation)
++{
++	struct ip6_hdr *ip6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
++	uint32_t packet_size = ntohs(ip6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
++
++	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
++    fs_add_bool(fs, "success", 1);
++}
++
++static fielddef_t fields[] = {
++	{.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
++	{.name="type", .type="int", .desc="icmp message type"},
++	{.name="code", .type="int", .desc="icmp message sub type code"},
++	{.name="icmp-id", .type="int", .desc="icmp id number"},
++	{.name="seq", .type="int", .desc="icmp sequence number"},
++    {.name="classification", .type="string", .desc="probe module classification"},
++	{.name="success", .type="int", .desc="did probe module classify response as success"}
++};
++
++
++probe_module_t module_icmp6_nmap_node_req = {
++	.name = "icmp6_nmap_node_req",
++	.packet_length = 86,
++	.pcap_filter = "icmp6", // and icmp6[0]=!8",
++	.pcap_snaplen =  500, // 14 ethernet header + 40 IPv6 header + 8 ICMPv6 header + 40 inner IPv6 header + 8 inner ICMPv6 header + 8 payload
++	.port_args = 1,
++	.global_initialize = &icmp6_nmap_node_req_global_initialize,
++	.thread_initialize = &icmp6_nmap_node_req_init_perthread,
++	.make_packet = &icmp6_nmap_node_req_make_packet,
++	.print_packet = &icmp6_nmap_node_req_print_packet,
++	.process_packet = &icmp6_nmap_node_req_process_packet,
++	.validate_packet = &icmp6_nmap_node_req_validate_packet,
++	.close = NULL,
++	.output_type = OUTPUT_TYPE_STATIC,
++	.fields = fields,
++	.numfields = 7};
++
+diff --git a/src/probe_modules/module_ipv6_nmap_tcp.c b/src/probe_modules/module_ipv6_nmap_tcp.c
+new file mode 100644
+index 0000000..72c6aa9
+--- /dev/null
++++ b/src/probe_modules/module_ipv6_nmap_tcp.c
+@@ -0,0 +1,218 @@
++/*
++ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
++ * Technical University of Munich
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
++ * use this file except in compliance with the License. You may obtain a copy
++ * of the License at http://www.apache.org/licenses/LICENSE-2.0
++ */
++
++// probe module for performing TCP SYN scans over IPv6
++
++// Needed for asprintf
++#ifndef _GNU_SOURCE
++#define _GNU_SOURCE 1
++#endif
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <stdint.h>
++#include <unistd.h>
++#include <string.h>
++#include <assert.h>
++
++#include "../../lib/includes.h"
++#include "../fieldset.h"
++#include "probe_modules.h"
++#include "packet.h"
++
++probe_module_t module_ipv6_nmap_tcp;
++static char* packet_type = NULL;
++static uint32_t num_ports;
++
++int ipv6_nmap_tcp_global_initialize(struct state_conf *state)
++{
++	num_ports = state->source_port_last - state->source_port_first + 1;
++
++	// Only look at received packets destined to the specified scanning address (useful for parallel zmap scans)
++	if (asprintf((char ** restrict) &module_ipv6_nmap_tcp.pcap_filter, "%s && ip6 dst host %s", module_ipv6_nmap_tcp.pcap_filter, state->ipv6_source_ip) == -1) {
++		return 1;
++	}
++
++    if(state->probe_args)
++    {
++        char *probe_args = state->probe_args;
++        if(strcmp(probe_args, "t5") == 0) 
++        {
++            packet_type = strdup(probe_args);
++        }
++        else if(strcmp(probe_args, "t6") == 0) 
++        {
++            packet_type = strdup(probe_args);
++        }
++        else if(strcmp(probe_args, "t7") == 0)
++        {
++            packet_type = strdup(probe_args);
++        }
++        else
++        {
++            printf("Invalid probe argument: options are: {t5 t6 t7}\n");
++            return EXIT_FAILURE;
++        }
++    }
++    else
++    {
++        packet_type = strdup("t5"); 
++    }
++
++	return EXIT_SUCCESS;
++}
++
++int ipv6_nmap_tcp_init_perthread(void* buf, macaddr_t *src,
++		macaddr_t *gw, port_h_t dst_port,
++		__attribute__((unused)) void **arg_ptr)
++{
++	memset(buf, 0, MAX_PACKET_SIZE);
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
++	struct ip6_hdr *ip6_header = (struct ip6_hdr*)(&eth_header[1]);
++	uint16_t payload_len = 40; // 20 TCP + 20 TCP Options
++	make_ip6_header(ip6_header, IPPROTO_TCP, payload_len);
++	struct tcphdr *tcp_header = (struct tcphdr*)(&ip6_header[1]);
++	make_tcp_header(tcp_header, dst_port, TH_SYN);
++	return EXIT_SUCCESS;
++}
++
++int ipv6_nmap_tcp_make_packet(void *buf, UNUSED size_t *buf_len, UNUSED ipaddr_n_t src_ip, UNUSED ipaddr_n_t dst_ip,
++        uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
++{
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	struct ip6_hdr *ip6_header = (struct ip6_hdr*) (&eth_header[1]);
++	struct tcphdr *tcp_header = (struct tcphdr*) (&ip6_header[1]);
++	void *tcp_options = (void *)(&tcp_header[1]);
++	uint32_t tcp_seq = validation[0];
++	uint8_t *tcp_opts;
++
++	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
++	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
++	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
++
++	tcp_header->th_sport = htons(get_src_port(num_ports,
++				probe_num, validation));
++	tcp_header->th_seq = 100;
++	tcp_header->th_off = 10;
++
++	if(strcmp(packet_type, "t5") == 0)
++    {
++        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
++        tcp_header->th_win = htons(31337);
++        tcp_header->th_flags = TH_SYN;
++    }
++    else if(strcmp(packet_type, "t6") == 0)
++    {
++        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
++        tcp_header->th_win = htons(32768);
++		// ip_header->ip_off = htons(IP_DF); IPv6 only fragments at end
++        tcp_header->th_flags = TH_ACK;
++    }
++    else
++    {
++        tcp_opts = (uint8_t *) "\x03\x03\x0F\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
++        tcp_header->th_win = htons(65535);
++        tcp_header->th_flags = (TH_FIN | TH_PUSH | TH_URG);
++    }
++
++	memcpy(tcp_options, tcp_opts, 20);
++
++	tcp_header->th_sum = tcp6_checksum(2*sizeof(struct tcphdr),
++			&ip6_header->ip6_src, &ip6_header->ip6_dst, tcp_header);
++
++	return EXIT_SUCCESS;
++}
++
++void ipv6_nmap_tcp_print_packet(FILE *fp, void* packet)
++{
++	struct ether_header *ethh = (struct ether_header *) packet;
++	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
++	struct tcphdr *tcph = (struct tcphdr *) &iph[1];
++	fprintf(fp, "tcp { source: %u | dest: %u | seq: %u | checksum: %#04X }\n",
++			ntohs(tcph->th_sport),
++			ntohs(tcph->th_dport),
++			ntohl(tcph->th_seq),
++			ntohs(tcph->th_sum));
++	fprintf_ipv6_header(fp, iph);
++	fprintf_eth_header(fp, ethh);
++	fprintf(fp, "------------------------------------------------------\n");
++}
++
++int ipv6_nmap_tcp_validate_packet(const struct ip *ip_hdr, uint32_t len,
++		__attribute__((unused))uint32_t *src_ip,
++		uint32_t *validation)
++{
++	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) ip_hdr;
++
++	if (ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_TCP) {
++		return 0;
++	}
++	if ((ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen)) > len) {
++		// buffer not large enough to contain expected tcp header, i.e. IPv6 payload
++		return 0;
++	}
++	struct tcphdr *tcp_hdr = (struct tcphdr*) (&ipv6_hdr[1]);
++	uint16_t sport = tcp_hdr->th_sport;
++	uint16_t dport = tcp_hdr->th_dport;
++	// validate source port
++	if (ntohs(sport) != zconf.target_port) {
++		return 0;
++	}
++	// validate destination port
++	if (!check_dst_port(ntohs(dport), num_ports, validation)) {
++		return 0;
++	}
++	// validate tcp acknowledgement number
++	if (htonl(tcp_hdr->th_ack) != htonl(validation[0])+1) {
++		return 0;
++	}
++	return 1;
++}
++
++void ipv6_nmap_tcp_process_packet(const u_char *packet,
++		__attribute__((unused)) uint32_t len, fieldset_t *fs,
++		__attribute__((unused)) uint32_t *validation)
++{
++	struct ether_header *eth_hdr = (struct ether_header *) packet;
++	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) (&eth_hdr[1]);
++	// struct tcphdr *tcp_hdr = (struct tcphdr*) (&ipv6_hdr[1]);
++	uint32_t packet_size = htons(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
++
++	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
++    fs_add_bool(fs, "success", 1);
++}
++
++static fielddef_t fields[] = {
++	{.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
++	{.name = "sport",  .type = "int", .desc = "TCP source port"},
++	{.name = "dport",  .type = "int", .desc = "TCP destination port"},
++	{.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
++	{.name = "classification", .type="string", .desc = "packet classification"},
++	{.name = "success", .type="int", .desc = "is response considered success"}
++};
++
++probe_module_t module_ipv6_nmap_tcp = {
++	.name = "ipv6_nmap_tcp",
++	.packet_length = 94, // 14 Ethernet + 40 IPv6 + 20 TCP + 20 Options
++	.pcap_filter = "ip6 proto 6",
++	.pcap_snaplen = 116, // was 96 for IPv4
++	.port_args = 1,
++	.global_initialize = &ipv6_nmap_tcp_global_initialize,
++	.thread_initialize = &ipv6_nmap_tcp_init_perthread,
++	.make_packet = &ipv6_nmap_tcp_make_packet,
++	.print_packet = &ipv6_nmap_tcp_print_packet,
++	.process_packet = &ipv6_nmap_tcp_process_packet,
++	.validate_packet = &ipv6_nmap_tcp_validate_packet,
++	.close = NULL,
++	.helptext = "Probe module that implements nmap closed port probes",
++	.output_type = OUTPUT_TYPE_STATIC,
++	.fields = fields,
++	.numfields = 6};
++
+diff --git a/src/probe_modules/module_ipv6_nmap_udp.c b/src/probe_modules/module_ipv6_nmap_udp.c
+new file mode 100644
+index 0000000..2cda6a0
+--- /dev/null
++++ b/src/probe_modules/module_ipv6_nmap_udp.c
+@@ -0,0 +1,154 @@
++/*
++ * ZMapv6 Copyright 2016 Chair of Network Architectures and Services
++ * Technical University of Munich
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
++ * use this file except in compliance with the License. You may obtain a copy
++ * of the License at http://www.apache.org/licenses/LICENSE-2.0
++ */
++
++// probe module for performing arbitrary UDP scans over IPv6
++
++// Needed for asprintf
++#ifndef _GNU_SOURCE
++#define _GNU_SOURCE 1
++#endif
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <stdint.h>
++#include <unistd.h>
++#include <string.h>
++#include <assert.h>
++
++#include "../../lib/includes.h"
++#include "../../lib/xalloc.h"
++#include "../../lib/lockfd.h"
++#include "logger.h"
++#include "probe_modules.h"
++#include "packet.h"
++#include "aesrand.h"
++#include "state.h"
++#include "module_udp.h"
++
++#define ICMP_UNREACH_HEADER_SIZE 8
++
++static int num_ports;
++
++probe_module_t module_ipv6_nmap_udp;
++
++int ipv6_nmap_udp_global_initialize(struct state_conf *conf) {
++	num_ports = conf->source_port_last - conf->source_port_first + 1;
++
++	return EXIT_SUCCESS;
++}
++
++int ipv6_nmap_udp_init_perthread(void* buf, macaddr_t *src,
++		macaddr_t *gw, __attribute__((unused)) port_h_t dst_port,\
++		void **arg_ptr)
++{
++	memset(buf, 0, MAX_PACKET_SIZE);
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	make_eth_header_ethertype(eth_header, src, gw, ETHERTYPE_IPV6);
++	struct ip6_hdr *ipv6_header = (struct ip6_hdr*)(&eth_header[1]);
++	uint16_t payload_len = 308; // 8 UDP + 300 Payload. htons is called by make_ip6_header
++	make_ip6_header(ipv6_header, IPPROTO_UDP, payload_len);
++
++	struct udphdr *udp_header = (struct udphdr*)(&ipv6_header[1]);
++	make_udp_header(udp_header, zconf.target_port, payload_len);
++
++	char* payload = (char*)(&udp_header[1]);
++	memset(payload, 0x43, 300);
++
++	return EXIT_SUCCESS;
++}
++
++int ipv6_nmap_udp_make_packet(void *buf, UNUSED size_t *buf_len, __attribute__((unused)) ipaddr_n_t src_ip,
++		__attribute__((unused)) ipaddr_n_t dst_ip, uint8_t ttl, uint32_t *validation, int probe_num, void *arg)
++{
++	// From module_ipv6_nmap_udp_dns
++	struct ether_header *eth_header = (struct ether_header *) buf;
++	struct ip6_hdr *ip6_header = (struct ip6_hdr*) (&eth_header[1]);
++	struct udphdr *udp_header= (struct udphdr *) &ip6_header[1];
++
++	ip6_header->ip6_src = ((struct in6_addr *) arg)[0];
++	ip6_header->ip6_dst = ((struct in6_addr *) arg)[1];
++	// ip_header->ip_id = htons(0x1042); doesn't exist in IPv6
++	ip6_header->ip6_ctlun.ip6_un1.ip6_un1_hlim = ttl;
++	udp_header->uh_sport = htons(43213);
++
++	udp_header->uh_sum = ipv6_udp_checksum(&ip6_header->ip6_src, &ip6_header->ip6_dst, udp_header);
++
++	return EXIT_SUCCESS;
++}
++
++void ipv6_nmap_udp_print_packet(FILE *fp, void* packet)
++{
++	struct ether_header *ethh = (struct ether_header *) packet;
++	struct ip6_hdr *iph = (struct ip6_hdr *) &ethh[1];
++	struct udphdr *udph  = (struct udphdr*) &iph[1];
++	fprintf(fp, "udp { source: %u | dest: %u | checksum: %#04X }\n",
++		ntohs(udph->uh_sport),
++		ntohs(udph->uh_dport),
++		ntohs(udph->uh_sum));
++	fprintf_ipv6_header(fp, iph);
++	fprintf_eth_header(fp, ethh);
++	fprintf(fp, "------------------------------------------------------\n");
++}
++
++void ipv6_nmap_udp_process_packet(const u_char *packet, UNUSED uint32_t len, fieldset_t *fs,
++		__attribute__((unused)) uint32_t *validation)
++{
++	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) &packet[sizeof(struct ether_header)];
++	uint32_t packet_size = ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen) + sizeof(struct ether_header);
++
++	fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
++    fs_add_bool(fs, "success", 1);
++}
++
++
++int ipv6_nmap_udp_validate_packet(const struct ip *ip_hdr, uint32_t len,
++		UNUSED uint32_t *src_ip, uint32_t *validation)
++{
++	struct ip6_hdr *ipv6_hdr = (struct ip6_hdr *) ip_hdr;
++
++	if (ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt != IPPROTO_UDP) {
++		return 0;
++	}
++
++	if ((ntohs(ipv6_hdr->ip6_ctlun.ip6_un1.ip6_un1_plen)) > len) {
++		// buffer not large enough to contain expected UDP header, i.e. IPv6 payload
++		return 0;
++	}
++	if (!ipv6_udp_validate_packet(ipv6_hdr, len, NULL, validation)) {
++		return 0;
++	}
++	return 1;
++}
++
++static fielddef_t fields[] = {
++	{.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
++	{.name = "sport", .type = "int", .desc = "UDP source port"},
++	{.name = "dport", .type = "int", .desc = "UDP destination port"},
++	{.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
++	{.name = "classification", .type="string", .desc = "packet classification"},
++	{.name = "success", .type="int", .desc = "is response considered success"},
++};
++
++probe_module_t module_ipv6_nmap_udp = {
++	.name = "ipv6_nmap_udp",
++	.packet_length = 362, // 14 Ethernet, 40 IPv6, 8 UDP, 300 Payload
++	.pcap_filter = "ip6 proto 17",
++	.pcap_snaplen = 1500,
++	.port_args = 1,
++	.thread_initialize = &ipv6_nmap_udp_init_perthread,
++	.global_initialize = &ipv6_nmap_udp_global_initialize,
++	.make_packet = &ipv6_nmap_udp_make_packet,
++	.print_packet = &ipv6_nmap_udp_print_packet,
++	.validate_packet = &ipv6_nmap_udp_validate_packet,
++	.process_packet = &ipv6_nmap_udp_process_packet,
++	.close = NULL,
++	.helptext = "Probe module that implements nmap closed port probes",
++	.output_type = OUTPUT_TYPE_STATIC,
++	.fields = fields,
++	.numfields = 6};
+diff --git a/src/probe_modules/module_ipv6_udp.c b/src/probe_modules/module_ipv6_udp.c
+index cdd8fb4..9cd2f39 100644
+--- a/src/probe_modules/module_ipv6_udp.c
++++ b/src/probe_modules/module_ipv6_udp.c
+@@ -119,6 +119,8 @@ int ipv6_udp_global_initialize(struct state_conf *conf) {
+ 
+ 	FILE *inp;
+ 
++	log_info("udp", "ASFDSAFDASFADS HI");
++
+ 	num_ports = conf->source_port_last - conf->source_port_first + 1;
+ 	udp_set_num_ports(num_ports);
+ 
+diff --git a/src/probe_modules/probe_modules.c b/src/probe_modules/probe_modules.c
+index 1562086..15fc39f 100644
+--- a/src/probe_modules/probe_modules.c
++++ b/src/probe_modules/probe_modules.c
+@@ -35,6 +35,11 @@ extern probe_module_t module_ipv6_tcp_synopt;
+ extern probe_module_t module_ipv6_udp;
+ extern probe_module_t module_ipv6_udp_dns;
+ extern probe_module_t module_icmp6_echoscan;
++extern probe_module_t module_icmp6_nmap_echo_1;
++extern probe_module_t module_icmp6_nmap_echo_2;
++extern probe_module_t module_icmp6_nmap_node_req;
++extern probe_module_t module_ipv6_nmap_tcp;
++extern probe_module_t module_ipv6_nmap_udp;
+ 
+ // ADD YOUR MODULE HERE
+ 
+@@ -54,7 +59,12 @@ probe_module_t* probe_modules[] = {
+ 	&module_ipv6_tcp_synopt,
+ 	&module_ipv6_udp,
+ 	&module_ipv6_udp_dns,
+-	&module_icmp6_echoscan
++	&module_icmp6_echoscan,
++	&module_icmp6_nmap_echo_1,
++	&module_icmp6_nmap_echo_2,
++	&module_icmp6_nmap_node_req,
++	&module_ipv6_nmap_tcp,
++	&module_ipv6_nmap_udp
+ 	// ADD YOUR MODULE HERE
+ };
+ 
+-- 
+2.20.1
+
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 9a28945..4bfa4da 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -30,6 +30,12 @@ set(PROBE_MODULE_SOURCES
     probe_modules/module_icmp_echo_time.c
     probe_modules/module_tcp_synscan.c
     probe_modules/module_tcp_synackscan.c
+    probe_modules/module_nmap_tcp.c
+    probe_modules/module_nmap_udp.c
+    probe_modules/module_nmap_icmp_echo_1.c
+    probe_modules/module_nmap_icmp_echo_2.c
+    probe_modules/module_icmp_timestamp.c
+    probe_modules/module_icmp_reply.c
 	#probe_modules/module_tcp_cisco_backdoor.c
     probe_modules/module_udp.c
     probe_modules/packet.c
diff --git a/src/probe_modules/module_icmp_echo.c b/src/probe_modules/module_icmp_echo.c
index 94ad413..c530277 100644
--- a/src/probe_modules/module_icmp_echo.c
+++ b/src/probe_modules/module_icmp_echo.c
@@ -129,6 +129,7 @@ static int icmp_validate_packet(const struct ip *ip_hdr, uint32_t len,
 		validate_gen(ip_hdr->ip_dst.s_addr, ip_inner->ip_dst.s_addr,
 			     (uint8_t *)validation);
 	}
+
 	// validate icmp id and seqnum
 	if (icmp_idnum != (validation[1] & 0xFFFF)) {
 		return 0;
@@ -146,41 +147,14 @@ static void icmp_echo_process_packet(const u_char *packet,
 				     uint32_t *validation)
 {
 	struct ip *ip_hdr = (struct ip *)&packet[sizeof(struct ether_header)];
-	struct icmp *icmp_hdr =
-	    (struct icmp *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
-	fs_add_uint64(fs, "type", icmp_hdr->icmp_type);
-	fs_add_uint64(fs, "code", icmp_hdr->icmp_code);
-	fs_add_uint64(fs, "icmp_id", ntohs(icmp_hdr->icmp_id));
-	fs_add_uint64(fs, "seq", ntohs(icmp_hdr->icmp_seq));
-	switch (icmp_hdr->icmp_type) {
-	case ICMP_ECHOREPLY:
-		fs_add_string(fs, "classification", (char *)"echoreply", 0);
-		fs_add_uint64(fs, "success", 1);
-		break;
-	case ICMP_UNREACH:
-		fs_add_string(fs, "classification", (char *)"unreach", 0);
-		fs_add_bool(fs, "success", 0);
-		break;
-	case ICMP_SOURCEQUENCH:
-		fs_add_string(fs, "classification", (char *)"sourcequench", 0);
-		fs_add_bool(fs, "success", 0);
-		break;
-	case ICMP_REDIRECT:
-		fs_add_string(fs, "classification", (char *)"redirect", 0);
-		fs_add_bool(fs, "success", 0);
-		break;
-	case ICMP_TIMXCEED:
-		fs_add_string(fs, "classification", (char *)"timxceed", 0);
-		fs_add_bool(fs, "success", 0);
-		break;
-	default:
-		fs_add_string(fs, "classification", (char *)"other", 0);
-		fs_add_bool(fs, "success", 0);
-		break;
-	}
+    uint32_t packet_size = htons(ip_hdr->ip_len) + sizeof(struct ether_header); // add ethernet bytes
+
+    fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
 }
 
 static fielddef_t fields[] = {
+    {.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
     {.name = "type", .type = "int", .desc = "icmp message type"},
     {.name = "code", .type = "int", .desc = "icmp message sub type code"},
     {.name = "icmp-id", .type = "int", .desc = "icmp id number"},
@@ -196,7 +170,7 @@ probe_module_t module_icmp_echo = {.name = "icmp_echoscan",
 				   .packet_length = 62,
 				   .pcap_filter = "icmp and icmp[0]!=8",
 				   .pcap_snaplen = 96,
-				   .port_args = 0,
+				   .port_args = 1,
 				   .thread_initialize =
 				       &icmp_echo_init_perthread,
 				   .make_packet = &icmp_echo_make_packet,
@@ -206,4 +180,4 @@ probe_module_t module_icmp_echo = {.name = "icmp_echoscan",
 				   .close = NULL,
 				   .output_type = OUTPUT_TYPE_STATIC,
 				   .fields = fields,
-				   .numfields = 6};
+				   .numfields = 7};
diff --git a/src/probe_modules/module_icmp_reply.c b/src/probe_modules/module_icmp_reply.c
new file mode 100644
index 0000000..41ce8ac
--- /dev/null
+++ b/src/probe_modules/module_icmp_reply.c
@@ -0,0 +1,219 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP reply request (ping) scans
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp_reply;
+
+static int icmp_reply_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+				    __attribute__((unused)) port_h_t dst_port,
+				    __attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	make_eth_header(eth_header, src, gw);
+
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	uint16_t len = htons(sizeof(struct ip) + sizeof(struct icmp) - 8);
+	make_ip_header(ip_header, IPPROTO_ICMP, len);
+
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+	make_icmp_header(icmp_header);
+
+	return EXIT_SUCCESS;
+}
+
+struct payload
+{
+    uint32_t load;
+};
+
+static int icmp_reply_make_packet(void *buf, UNUSED size_t *buf_len,
+				 ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+				 uint32_t *validation, UNUSED int probe_num,
+				 UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+    struct payload *pload = (struct payload *) (&icmp_header[1]);
+
+	uint16_t icmp_idnum = validation[1] & 0xFFFF;
+	uint16_t icmp_seqnum = validation[2] & 0xFFFF;
+
+	ip_header->ip_src.s_addr = src_ip;
+	ip_header->ip_dst.s_addr = dst_ip;
+	ip_header->ip_ttl = ttl;
+    ip_header->ip_len = htons(32);
+
+    icmp_header->icmp_type = 0;
+    icmp_header->icmp_code = 0;
+	icmp_header->icmp_id = 1234;
+	icmp_header->icmp_seq = 9876;
+    pload->load = htonl(3345);
+
+	icmp_header->icmp_cksum = 0;
+	icmp_header->icmp_cksum = icmp_checksum((unsigned short *)icmp_header);
+
+	ip_header->ip_sum = 0;
+	ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp_reply_print_packet(FILE *fp, void *packet)
+{
+	struct ether_header *ethh = (struct ether_header *)packet;
+	struct ip *iph = (struct ip *)&ethh[1];
+	struct icmp *icmp_header = (struct icmp *)(&iph[1]);
+
+	fprintf(fp,
+		"icmp { type: %u | code: %u "
+		"| checksum: %#04X | id: %u | seq: %u }\n",
+		icmp_header->icmp_type, icmp_header->icmp_code,
+		ntohs(icmp_header->icmp_cksum), ntohs(icmp_header->icmp_id),
+		ntohs(icmp_header->icmp_seq));
+	fprintf_ip_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+static int icmp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+				uint32_t *src_ip, uint32_t *validation)
+{
+	if (ip_hdr->ip_p != IPPROTO_ICMP) {
+		return 0;
+	}
+	// check if buffer is large enough to contain expected icmp header
+	if (((uint32_t)4 * ip_hdr->ip_hl + ICMP_SMALLEST_SIZE) > len) {
+		return 0;
+	}
+	struct icmp *icmp_h =
+	    (struct icmp *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+	uint16_t icmp_idnum = icmp_h->icmp_id;
+	uint16_t icmp_seqnum = icmp_h->icmp_seq;
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp_h->icmp_type == ICMP_TIMXCEED ||
+	    icmp_h->icmp_type == ICMP_UNREACH) {
+		// Should have 16B TimeExceeded/Dest_Unreachable header +
+		// original IP header + 1st 8B of original ICMP frame
+		if ((4 * ip_hdr->ip_hl + ICMP_TIMXCEED_UNREACH_HEADER_SIZE +
+		     sizeof(struct ip)) > len) {
+			return 0;
+		}
+		struct ip *ip_inner = (struct ip *)((char *)icmp_h + 8);
+		if (((uint32_t)4 * ip_hdr->ip_hl +
+		     ICMP_TIMXCEED_UNREACH_HEADER_SIZE + 4 * ip_inner->ip_hl +
+		     8 /*1st 8 bytes of original*/) > len) {
+			return 0;
+		}
+		struct icmp *icmp_inner =
+		    (struct icmp *)((char *)ip_inner + 4 * ip_hdr->ip_hl);
+		// Regenerate validation and icmp id based off inner payload
+		icmp_idnum = icmp_inner->icmp_id;
+		icmp_seqnum = icmp_inner->icmp_seq;
+		*src_ip = ip_inner->ip_dst.s_addr;
+		validate_gen(ip_hdr->ip_dst.s_addr, ip_inner->ip_dst.s_addr,
+			     (uint8_t *)validation);
+	}
+	// validate icmp id and seqnum
+	if (icmp_idnum != (validation[1] & 0xFFFF)) {
+		return 0;
+	}
+	if (icmp_seqnum != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+	return 1;
+}
+
+static void icmp_reply_process_packet(const u_char *packet,
+				     __attribute__((unused)) uint32_t len,
+				     fieldset_t *fs,
+				     __attribute__((unused))
+				     uint32_t *validation)
+{
+	struct ip *ip_hdr = (struct ip *)&packet[sizeof(struct ether_header)];
+	struct icmp *icmp_hdr =
+	    (struct icmp *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+	fs_add_uint64(fs, "type", icmp_hdr->icmp_type);
+	fs_add_uint64(fs, "code", icmp_hdr->icmp_code);
+	fs_add_uint64(fs, "icmp_id", ntohs(icmp_hdr->icmp_id));
+	fs_add_uint64(fs, "seq", ntohs(icmp_hdr->icmp_seq));
+	switch (icmp_hdr->icmp_type) {
+	case ICMP_ECHOREPLY:
+		fs_add_string(fs, "classification", (char *)"replyreply", 0);
+		fs_add_uint64(fs, "success", 1);
+		break;
+	case ICMP_UNREACH:
+		fs_add_string(fs, "classification", (char *)"unreach", 0);
+		fs_add_bool(fs, "success", 0);
+		break;
+	case ICMP_SOURCEQUENCH:
+		fs_add_string(fs, "classification", (char *)"sourcequench", 0);
+		fs_add_bool(fs, "success", 0);
+		break;
+	case ICMP_REDIRECT:
+		fs_add_string(fs, "classification", (char *)"redirect", 0);
+		fs_add_bool(fs, "success", 0);
+		break;
+	case ICMP_TIMXCEED:
+		fs_add_string(fs, "classification", (char *)"timxceed", 0);
+		fs_add_bool(fs, "success", 0);
+		break;
+	default:
+		fs_add_string(fs, "classification", (char *)"other", 0);
+		fs_add_bool(fs, "success", 0);
+		break;
+	}
+}
+
+static fielddef_t fields[] = {
+    {.name = "type", .type = "int", .desc = "icmp message type"},
+    {.name = "code", .type = "int", .desc = "icmp message sub type code"},
+    {.name = "icmp-id", .type = "int", .desc = "icmp id number"},
+    {.name = "seq", .type = "int", .desc = "icmp sequence number"},
+    {.name = "classification",
+     .type = "string",
+     .desc = "probe module classification"},
+    {.name = "success",
+     .type = "bool",
+     .desc = "did probe module classify response as success"}};
+
+probe_module_t module_icmp_reply = {.name = "icmp_replyscan",
+				   .packet_length = 46,
+				   .pcap_filter = "icmp",
+				   .pcap_snaplen = 96,
+				   .port_args = 0,
+				   .thread_initialize =
+				       &icmp_reply_init_perthread,
+				   .make_packet = &icmp_reply_make_packet,
+				   .print_packet = &icmp_reply_print_packet,
+				   .process_packet = &icmp_reply_process_packet,
+				   .validate_packet = &icmp_validate_packet,
+				   .close = NULL,
+				   .output_type = OUTPUT_TYPE_STATIC,
+				   .fields = fields,
+				   .numfields = 7};
diff --git a/src/probe_modules/module_icmp_timestamp.c b/src/probe_modules/module_icmp_timestamp.c
new file mode 100644
index 0000000..84abcd8
--- /dev/null
+++ b/src/probe_modules/module_icmp_timestamp.c
@@ -0,0 +1,154 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing ICMP echo request (ping) scans
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_icmp_timestamp;
+
+static int icmp_timestamp_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+				    __attribute__((unused)) port_h_t dst_port,
+				    __attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	make_eth_header(eth_header, src, gw);
+
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	uint16_t len = htons(sizeof(struct ip) + sizeof(struct icmp) - 8);
+	make_ip_header(ip_header, IPPROTO_ICMP, len);
+
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+	make_icmp_header(icmp_header);
+
+	return EXIT_SUCCESS;
+}
+
+static int icmp_timestamp_make_packet(void *buf, UNUSED size_t *buf_len,
+				 ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+				 uint32_t *validation, UNUSED int probe_num,
+				 UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+
+	uint16_t icmp_idnum = validation[1] & 0xFFFF;
+	uint16_t icmp_seqnum = validation[2] & 0xFFFF;
+
+	ip_header->ip_src.s_addr = src_ip;
+	ip_header->ip_dst.s_addr = dst_ip;
+	ip_header->ip_ttl = ttl;
+    ip_header->ip_len = htons(40);
+
+    icmp_header->icmp_type = 13;
+    icmp_header->icmp_code = 0;
+	icmp_header->icmp_id = 1234;
+	icmp_header->icmp_seq = 9876;
+    icmp_header->icmp_otime = htonl(12345);
+    icmp_header->icmp_rtime = htonl(54321);
+    icmp_header->icmp_ttime = htonl(34521);
+
+    icmp_header->icmp_cksum = 0;
+	icmp_header->icmp_cksum = icmp_checksum((unsigned short *)icmp_header);
+	ip_header->ip_sum = 0;
+	ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
+
+	return EXIT_SUCCESS;
+}
+
+static void icmp_timestamp_print_packet(FILE *fp, void *packet)
+{
+	struct ether_header *ethh = (struct ether_header *)packet;
+	struct ip *iph = (struct ip *)&ethh[1];
+	struct icmp *icmp_header = (struct icmp *)(&iph[1]);
+
+	fprintf(fp,
+		"icmp { type: %u | code: %u "
+		"| checksum: %#04X | id: %u | seq: %u }\n",
+		icmp_header->icmp_type, icmp_header->icmp_code,
+		ntohs(icmp_header->icmp_cksum), ntohs(icmp_header->icmp_id),
+		ntohs(icmp_header->icmp_seq));
+	fprintf_ip_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+static int icmp_timestamp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+				uint32_t *src_ip, uint32_t *validation)
+{
+	if (ip_hdr->ip_p != IPPROTO_ICMP) {
+		return 0;
+	}
+	// check if buffer is large enough to contain expected icmp header
+	if (((uint32_t)4 * ip_hdr->ip_hl + ICMP_SMALLEST_SIZE) > len) {
+		return 0;
+	}
+	struct icmp *icmp_h =
+	    (struct icmp *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+
+    if(icmp_h->icmp_type != ICMP_TSTAMPREPLY) return 0;
+
+    return 1;
+}
+
+static void icmp_timestamp_process_packet(const u_char *packet,
+				     __attribute__((unused)) uint32_t len,
+				     fieldset_t *fs,
+				     __attribute__((unused))
+				     uint32_t *validation)
+{
+	struct ip *ip_hdr = (struct ip *)&packet[sizeof(struct ether_header)];
+    uint32_t packet_size = htons(ip_hdr->ip_len) + sizeof(struct ether_header); // add ethernet bytes
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+    {.name = "bitstring", .type = "string", .desc = "bitstring"},
+    {.name = "type", .type = "int", .desc = "icmp message type"},
+    {.name = "code", .type = "int", .desc = "icmp message sub type code"},
+    {.name = "icmp-id", .type = "int", .desc = "icmp id number"},
+    {.name = "seq", .type = "int", .desc = "icmp sequence number"},
+    {.name = "classification",
+     .type = "string",
+     .desc = "probe module classification"},
+    {.name = "success",
+     .type = "bool",
+     .desc = "did probe module classify response as success"}};
+
+probe_module_t module_icmp_timestamp = {.name = "icmp_timestamp",
+				   .packet_length = 54,
+				   .pcap_filter = "icmp",
+				   .pcap_snaplen = 96,
+				   .port_args = 0,
+				   .thread_initialize =
+				       &icmp_timestamp_init_perthread,
+				   .make_packet = &icmp_timestamp_make_packet,
+				   .print_packet = &icmp_timestamp_print_packet,
+				   .process_packet = &icmp_timestamp_process_packet,
+				   .validate_packet = &icmp_timestamp_validate_packet,
+				   .close = NULL,
+				   .output_type = OUTPUT_TYPE_STATIC,
+				   .fields = fields,
+				   .numfields = 7};
diff --git a/src/probe_modules/module_nmap_icmp_echo_1.c b/src/probe_modules/module_nmap_icmp_echo_1.c
new file mode 100644
index 0000000..a217919
--- /dev/null
+++ b/src/probe_modules/module_nmap_icmp_echo_1.c
@@ -0,0 +1,190 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_nmap_icmp_echo_1;
+
+static int nmap_icmp_echo_1_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+				    __attribute__((unused)) port_h_t dst_port,
+				    __attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	make_eth_header(eth_header, src, gw);
+
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+    uint16_t len = htons(20 + 8 + 120);
+	make_ip_header(ip_header, IPPROTO_ICMP, len);
+
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+	make_icmp_header(icmp_header);
+
+    char *payload = (char *)(&icmp_header[1]);
+    memset(payload, 0x00, 120);
+
+	return EXIT_SUCCESS;
+}
+
+static int nmap_icmp_echo_1_make_packet(void *buf, UNUSED size_t *buf_len,
+				 ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+				 uint32_t *validation, UNUSED int probe_num,
+				 UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+
+
+    uint16_t icmp_idnum = validation[1] & 0xFFFF;
+	uint16_t icmp_seqnum = validation[2] & 0xFFFF;
+
+	ip_header->ip_src.s_addr = src_ip;
+	ip_header->ip_dst.s_addr = dst_ip;
+	ip_header->ip_ttl = ttl;
+
+	icmp_header->icmp_id = icmp_idnum;
+	icmp_header->icmp_seq = icmp_seqnum;
+
+    // NMAP icmp probe 1 options
+    ip_header->ip_off = htons(IP_DF);
+    ip_header->ip_tos = 0;
+    icmp_header->icmp_code = 9;
+
+	icmp_header->icmp_cksum = 0;
+	icmp_header->icmp_cksum = icmp_checksum((unsigned short *)icmp_header);
+
+	ip_header->ip_sum = 0;
+	ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
+
+	return EXIT_SUCCESS;
+}
+
+static void nmap_icmp_echo_1_print_packet(FILE *fp, void *packet)
+{
+	struct ether_header *ethh = (struct ether_header *)packet;
+	struct ip *iph = (struct ip *)&ethh[1];
+	struct icmp *icmp_header = (struct icmp *)(&iph[1]);
+
+	fprintf(fp,
+		"icmp { type: %u | code: %u "
+		"| checksum: %#04X | id: %u | seq: %u }\n",
+		icmp_header->icmp_type, icmp_header->icmp_code,
+		ntohs(icmp_header->icmp_cksum), ntohs(icmp_header->icmp_id),
+		ntohs(icmp_header->icmp_seq));
+	fprintf_ip_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+static int icmp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+				uint32_t *src_ip, uint32_t *validation)
+{
+	if (ip_hdr->ip_p != IPPROTO_ICMP) {
+		return 0;
+	}
+	// check if buffer is large enough to contain expected icmp header
+	if (((uint32_t)4 * ip_hdr->ip_hl + ICMP_SMALLEST_SIZE) > len) {
+		return 0;
+	}
+	struct icmp *icmp_h =
+	    (struct icmp *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+	uint16_t icmp_idnum = icmp_h->icmp_id;
+	uint16_t icmp_seqnum = icmp_h->icmp_seq;
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp_h->icmp_type == ICMP_TIMXCEED ||
+	    icmp_h->icmp_type == ICMP_UNREACH) {
+		// Should have 16B TimeExceeded/Dest_Unreachable header +
+		// original IP header + 1st 8B of original ICMP frame
+		if ((4 * ip_hdr->ip_hl + ICMP_TIMXCEED_UNREACH_HEADER_SIZE +
+		     sizeof(struct ip)) > len) {
+			return 0;
+		}
+		struct ip *ip_inner = (struct ip *)((char *)icmp_h + 8);
+		if (((uint32_t)4 * ip_hdr->ip_hl +
+		     ICMP_TIMXCEED_UNREACH_HEADER_SIZE + 4 * ip_inner->ip_hl +
+		     8 /*1st 8 bytes of original*/) > len) {
+			return 0;
+		}
+		struct icmp *icmp_inner =
+		    (struct icmp *)((char *)ip_inner + 4 * ip_hdr->ip_hl);
+		// Regenerate validation and icmp id based off inner payload
+		icmp_idnum = icmp_inner->icmp_id;
+		icmp_seqnum = icmp_inner->icmp_seq;
+		*src_ip = ip_inner->ip_dst.s_addr;
+		validate_gen(ip_hdr->ip_dst.s_addr, ip_inner->ip_dst.s_addr,
+			     (uint8_t *)validation);
+	}
+
+
+	if (icmp_idnum != (validation[1] & 0xFFFF)) {
+		return 0;
+	}
+	if (icmp_seqnum != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+	return 1;
+}
+
+static void nmap_icmp_echo_1_process_packet(const u_char *packet,
+				     __attribute__((unused)) uint32_t len,
+				     fieldset_t *fs,
+				     __attribute__((unused))
+				     uint32_t *validation)
+{
+	struct ip *ip_hdr = (struct ip *)&packet[sizeof(struct ether_header)];
+    uint32_t packet_size = htons(ip_hdr->ip_len) + sizeof(struct ether_header); // add ethernet bytes
+
+    fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+    {.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+    {.name = "type", .type = "int", .desc = "icmp message type"},
+    {.name = "code", .type = "int", .desc = "icmp message sub type code"},
+    {.name = "icmp-id", .type = "int", .desc = "icmp id number"},
+    {.name = "seq", .type = "int", .desc = "icmp sequence number"},
+    {.name = "classification",
+     .type = "string",
+     .desc = "probe module classification"},
+    {.name = "success",
+     .type = "bool",
+     .desc = "did probe module classify response as success"}};
+
+probe_module_t module_nmap_icmp_echo_1 = {.name = "nmap_icmp_echo_1",
+				   .packet_length = 170,
+				   .pcap_filter = "icmp and icmp[0]!=8",
+				   .pcap_snaplen = 300,
+				   .port_args = 1,
+				   .thread_initialize =
+				       &nmap_icmp_echo_1_init_perthread,
+				   .make_packet = &nmap_icmp_echo_1_make_packet,
+				   .print_packet = &nmap_icmp_echo_1_print_packet,
+				   .process_packet = &nmap_icmp_echo_1_process_packet,
+				   .validate_packet = &icmp_validate_packet,
+				   .close = NULL,
+				   .output_type = OUTPUT_TYPE_STATIC,
+				   .fields = fields,
+				   .numfields = 7};
diff --git a/src/probe_modules/module_nmap_icmp_echo_2.c b/src/probe_modules/module_nmap_icmp_echo_2.c
new file mode 100644
index 0000000..ed44db8
--- /dev/null
+++ b/src/probe_modules/module_nmap_icmp_echo_2.c
@@ -0,0 +1,189 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "../../lib/includes.h"
+#include "probe_modules.h"
+#include "../fieldset.h"
+#include "packet.h"
+#include "validate.h"
+
+#define ICMP_SMALLEST_SIZE 5
+#define ICMP_TIMXCEED_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_nmap_icmp_echo_2;
+
+static int nmap_icmp_echo_2_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+				    __attribute__((unused)) port_h_t dst_port,
+				    __attribute__((unused)) void **arg_ptr)
+{
+	memset(buf, 0, MAX_PACKET_SIZE);
+
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	make_eth_header(eth_header, src, gw);
+
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+    uint16_t len = htons(20 + 8 + 150);
+	make_ip_header(ip_header, IPPROTO_ICMP, len);
+
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+	make_icmp_header(icmp_header);
+
+    char *payload = (char *)(&icmp_header[1]);
+    memset(payload, 0x00, 150);
+
+	return EXIT_SUCCESS;
+}
+
+static int nmap_icmp_echo_2_make_packet(void *buf, UNUSED size_t *buf_len,
+				 ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+				 uint32_t *validation, UNUSED int probe_num,
+				 UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	struct icmp *icmp_header = (struct icmp *)(&ip_header[1]);
+
+
+    uint16_t icmp_idnum = validation[1] & 0xFFFF;
+	uint16_t icmp_seqnum = validation[2] & 0xFFFF;
+
+	ip_header->ip_src.s_addr = src_ip;
+	ip_header->ip_dst.s_addr = dst_ip;
+	ip_header->ip_ttl = ttl;
+
+	icmp_header->icmp_id = icmp_idnum;
+	icmp_header->icmp_seq = icmp_seqnum;
+
+    // NMAP icmp probe 2 options
+    ip_header->ip_tos = 4;
+    icmp_header->icmp_code = 0;
+
+	icmp_header->icmp_cksum = 0;
+	icmp_header->icmp_cksum = icmp_checksum((unsigned short *)icmp_header);
+
+	ip_header->ip_sum = 0;
+	ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
+
+	return EXIT_SUCCESS;
+}
+
+static void nmap_icmp_echo_2_print_packet(FILE *fp, void *packet)
+{
+	struct ether_header *ethh = (struct ether_header *)packet;
+	struct ip *iph = (struct ip *)&ethh[1];
+	struct icmp *icmp_header = (struct icmp *)(&iph[1]);
+
+	fprintf(fp,
+		"icmp { type: %u | code: %u "
+		"| checksum: %#04X | id: %u | seq: %u }\n",
+		icmp_header->icmp_type, icmp_header->icmp_code,
+		ntohs(icmp_header->icmp_cksum), ntohs(icmp_header->icmp_id),
+		ntohs(icmp_header->icmp_seq));
+	fprintf_ip_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+static int icmp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+				uint32_t *src_ip, uint32_t *validation)
+{
+	if (ip_hdr->ip_p != IPPROTO_ICMP) {
+		return 0;
+	}
+	// check if buffer is large enough to contain expected icmp header
+	if (((uint32_t)4 * ip_hdr->ip_hl + ICMP_SMALLEST_SIZE) > len) {
+		return 0;
+	}
+	struct icmp *icmp_h =
+	    (struct icmp *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+	uint16_t icmp_idnum = icmp_h->icmp_id;
+	uint16_t icmp_seqnum = icmp_h->icmp_seq;
+	// ICMP validation is tricky: for some packet types, we must look inside
+	// the payload
+	if (icmp_h->icmp_type == ICMP_TIMXCEED ||
+	    icmp_h->icmp_type == ICMP_UNREACH) {
+		// Should have 16B TimeExceeded/Dest_Unreachable header +
+		// original IP header + 1st 8B of original ICMP frame
+		if ((4 * ip_hdr->ip_hl + ICMP_TIMXCEED_UNREACH_HEADER_SIZE +
+		     sizeof(struct ip)) > len) {
+			return 0;
+		}
+		struct ip *ip_inner = (struct ip *)((char *)icmp_h + 8);
+		if (((uint32_t)4 * ip_hdr->ip_hl +
+		     ICMP_TIMXCEED_UNREACH_HEADER_SIZE + 4 * ip_inner->ip_hl +
+		     8 /*1st 8 bytes of original*/) > len) {
+			return 0;
+		}
+		struct icmp *icmp_inner =
+		    (struct icmp *)((char *)ip_inner + 4 * ip_hdr->ip_hl);
+		// Regenerate validation and icmp id based off inner payload
+		icmp_idnum = icmp_inner->icmp_id;
+		icmp_seqnum = icmp_inner->icmp_seq;
+		*src_ip = ip_inner->ip_dst.s_addr;
+		validate_gen(ip_hdr->ip_dst.s_addr, ip_inner->ip_dst.s_addr,
+			     (uint8_t *)validation);
+	}
+
+
+	if (icmp_idnum != (validation[1] & 0xFFFF)) {
+		return 0;
+	}
+	if (icmp_seqnum != (validation[2] & 0xFFFF)) {
+		return 0;
+	}
+	return 1;
+}
+
+static void nmap_icmp_echo_2_process_packet(const u_char *packet,
+				     __attribute__((unused)) uint32_t len,
+				     fieldset_t *fs,
+				     __attribute__((unused))
+				     uint32_t *validation)
+{
+	struct ip *ip_hdr = (struct ip *)&packet[sizeof(struct ether_header)];
+    uint32_t packet_size = htons(ip_hdr->ip_len) + sizeof(struct ether_header); // add ethernet bytes
+
+    fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+    {.name = "bitstring", .type = "binary", .desc = "bitstring of packet"},
+    {.name = "type", .type = "int", .desc = "icmp message type"},
+    {.name = "code", .type = "int", .desc = "icmp message sub type code"},
+    {.name = "icmp-id", .type = "int", .desc = "icmp id number"},
+    {.name = "seq", .type = "int", .desc = "icmp sequence number"},
+    {.name = "classification",
+     .type = "string",
+     .desc = "probe module classification"},
+    {.name = "success",
+     .type = "bool",
+     .desc = "did probe module classify response as success"}};
+
+probe_module_t module_nmap_icmp_echo_2 = {.name = "nmap_icmp_echo_2",
+				   .packet_length = 200,
+				   .pcap_filter = "icmp and icmp[0]!=8",
+				   .pcap_snaplen = 300,
+				   .port_args = 1,
+				   .thread_initialize =
+				       &nmap_icmp_echo_2_init_perthread,
+				   .make_packet = &nmap_icmp_echo_2_make_packet,
+				   .print_packet = &nmap_icmp_echo_2_print_packet,
+				   .process_packet = &nmap_icmp_echo_2_process_packet,
+				   .validate_packet = &icmp_validate_packet,
+				   .close = NULL,
+				   .output_type = OUTPUT_TYPE_STATIC,
+				   .fields = fields,
+				   .numfields = 7};
diff --git a/src/probe_modules/module_nmap_tcp.c b/src/probe_modules/module_nmap_tcp.c
new file mode 100644
index 0000000..2158731
--- /dev/null
+++ b/src/probe_modules/module_nmap_tcp.c
@@ -0,0 +1,211 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for NMAP TCP nmap_tcp probe
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../fieldset.h"
+#include "probe_modules.h"
+#include "packet.h"
+
+probe_module_t module_nmap_tcp;
+
+static char* packet_type = NULL;
+static uint32_t num_ports;
+
+void nmap_tcp_print_packet(FILE *fp, void *packet)
+{
+	struct ether_header *ethh = (struct ether_header *)packet;
+	struct ip *iph = (struct ip *)&ethh[1];
+	struct tcphdr *tcph = (struct tcphdr *)&iph[1];
+	fprintf(fp,
+		"source: %u | dest: %u | seq: %u | checksum: %#04X }\n",
+		ntohs(tcph->th_win), ntohs(tcph->th_dport),
+		ntohl(tcph->th_seq), ntohs(tcph->th_sum));
+	fprintf_ip_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+static int nmap_tcp_global_initialize(struct state_conf *state)
+{
+	num_ports = state->source_port_last - state->source_port_first + 1;
+
+    if(state->probe_args)
+    {
+        char *probe_args = state->probe_args;
+        if(strcmp(probe_args, "t5") == 0)
+        {
+            packet_type = strdup(probe_args);
+        }
+        else if(strcmp(probe_args, "t6") == 0)
+        {
+            packet_type = strdup(probe_args);
+        }
+        else if(strcmp(probe_args, "t7") == 0)
+        {
+            packet_type = strdup(probe_args);
+        }
+        else
+        {
+            printf("Invalid probe argument: options are: {t5 t6 t7}\n");
+            return EXIT_FAILURE;
+        }
+    }
+    else
+    {
+        packet_type = strdup("t5");
+    }
+
+	return EXIT_SUCCESS;
+}
+
+static int nmap_tcp_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+				  port_h_t dst_port,
+				  __attribute__((unused)) void **arg_ptr)
+{
+    memset(buf, 0, MAX_PACKET_SIZE);
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	make_eth_header(eth_header, src, gw);
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+    uint16_t ip_len = htons(60);
+	make_ip_header(ip_header, IPPROTO_TCP, ip_len);
+	struct tcphdr *tcp_header = (struct tcphdr *)(&ip_header[1]);
+	make_tcp_header(tcp_header, dst_port, TH_SYN);
+	return EXIT_SUCCESS;
+}
+
+static int nmap_tcp_make_packet(void *buf, UNUSED size_t *buf_len,
+			       ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+			       uint32_t *validation, int probe_num,
+			       UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	struct tcphdr *tcp_header = (struct tcphdr *)(&ip_header[1]);
+    void *tcp_options = (void *)(&tcp_header[1]);
+	uint32_t tcp_seq = validation[0];
+    uint8_t *tcp_opts;
+
+    ip_header->ip_src.s_addr = src_ip;
+	ip_header->ip_dst.s_addr = dst_ip;
+	ip_header->ip_ttl = ttl;
+
+	tcp_header->th_sport =
+	    htons(get_src_port(num_ports, probe_num, validation));
+	tcp_header->th_seq = 100;
+	tcp_header->th_sum = 0;
+    tcp_header->th_off = 10;
+
+    if(strcmp(packet_type, "t5") == 0)
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(31337);
+        tcp_header->th_flags = TH_SYN;
+    }
+    else if(strcmp(packet_type, "t6") == 0)
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0A\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(32768);
+        ip_header->ip_off = htons(IP_DF);
+        tcp_header->th_flags = TH_ACK;
+    }
+    else
+    {
+        tcp_opts = (uint8_t *) "\x03\x03\x0F\x01\x02\x04\x01\x09\x08\x0A\xFF\xFF\xFF\xFF\x00\x00\x00\x00\x04\x02";
+        tcp_header->th_win = htons(65535);
+        tcp_header->th_flags = (TH_FIN | TH_PUSH | TH_URG);
+    }
+
+    // set tcp options
+    memcpy(tcp_options, tcp_opts, 20);
+
+	tcp_header->th_sum =
+	    tcp_checksum(sizeof(struct tcphdr) + sizeof(uint8_t) * 20, ip_header->ip_src.s_addr,
+			 ip_header->ip_dst.s_addr, tcp_header);
+
+	ip_header->ip_sum = 0;
+	ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
+
+	return EXIT_SUCCESS;
+}
+
+static int nmap_tcp_validate_packet(const struct ip *ip_hdr, UNUSED uint32_t len,
+				   __attribute__((unused)) uint32_t *src_ip,
+				   uint32_t *validation)
+{
+	if (ip_hdr->ip_p != IPPROTO_TCP) {
+		return 0;
+	}
+
+	struct tcphdr *tcp =
+	    (struct tcphdr *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+	uint16_t sport = tcp->th_sport;
+	uint16_t dport = tcp->th_dport;
+
+    // validate source port
+	if (ntohs(sport) != zconf.target_port) {
+		return 0;
+	}
+	// validate destination port
+	if (!check_dst_port(ntohs(dport), num_ports, validation)) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static void nmap_tcp_process_packet(const u_char *packet,
+				   __attribute__((unused)) uint32_t len,
+				   fieldset_t *fs,
+				   __attribute__((unused)) uint32_t *validation)
+
+{
+	struct ip *ip_hdr = (struct ip *)&packet[sizeof(struct ether_header)];
+    uint32_t packet_size = htons(ip_hdr->ip_len) + sizeof(struct ether_header); // add ethernet bytes
+
+    fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+    {.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
+    {.name = "sport", .type = "int", .desc = "TCP source port"},
+    {.name = "dport", .type = "int", .desc = "TCP destination port"},
+    {.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
+    {.name = "classification",
+     .type = "string",
+     .desc = "packet classification"},
+    {.name = "success",
+     .type = "bool",
+     .desc = "is response considered success"}};
+
+probe_module_t module_nmap_tcp = {
+    .name = "nmap_tcp",
+    .packet_length = 74,
+    .pcap_filter = "tcp",
+    .pcap_snaplen = 96,
+    .port_args = 1,
+    .global_initialize = &nmap_tcp_global_initialize,
+    .thread_initialize = &nmap_tcp_init_perthread,
+    .make_packet = &nmap_tcp_make_packet,
+    .print_packet = &nmap_tcp_print_packet,
+    .process_packet = &nmap_tcp_process_packet,
+    .validate_packet = &nmap_tcp_validate_packet,
+    .close = NULL,
+    .helptext = "Probe module that implements nmap closed port probes",
+    .output_type = OUTPUT_TYPE_STATIC,
+    .fields = fields,
+    .numfields = 6};
diff --git a/src/probe_modules/module_nmap_tcp.h b/src/probe_modules/module_nmap_tcp.h
new file mode 100644
index 0000000..f77bca5
--- /dev/null
+++ b/src/probe_modules/module_nmap_tcp.h
@@ -0,0 +1,42 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing TCP SYN scans
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../fieldset.h"
+#include "probe_modules.h"
+#include "packet.h"
+
+int nmap_global_initialize(struct state_conf *state);
+
+int nmap_tcp_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+			   port_h_t dst_port,
+			   __attribute__((unused)) void **arg_ptr);
+
+int nmap_tcp_make_packet(void *buf, ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+			uint32_t *validation, int probe_num,
+			__attribute__((unused)) void *arg);
+
+void nmap_tcp_print_packet(FILE *fp, void *packet);
+
+int nmap_tcp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+			    __attribute__((unused)) uint32_t *src_ip,
+			    uint32_t *validation);
+
+void nmap_tcp_process_packet(const u_char *packet,
+			    __attribute__((unused)) uint32_t len,
+			    fieldset_t *fs,
+			    __attribute__((unused)) uint32_t *validation);
diff --git a/src/probe_modules/module_nmap_udp.c b/src/probe_modules/module_nmap_udp.c
new file mode 100644
index 0000000..ba15f1c
--- /dev/null
+++ b/src/probe_modules/module_nmap_udp.c
@@ -0,0 +1,200 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for NMAP TCP nmap_udp probe
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../fieldset.h"
+#include "probe_modules.h"
+#include "packet.h"
+
+#define ICMP_UNREACH_HEADER_SIZE 8
+
+probe_module_t module_nmap_udp;
+
+static uint32_t num_ports;
+
+void nmap_udp_print_packet(FILE *fp, void *packet)
+{
+	struct ether_header *ethh = (struct ether_header *)packet;
+	struct ip *iph = (struct ip *)&ethh[1];
+	struct udphdr *udph = (struct udphdr *)(&iph[1]);
+	fprintf(fp, "udp { source: %u | dest: %u | checksum: %#04X }\n",
+		ntohs(udph->uh_sport), ntohs(udph->uh_dport),
+		ntohs(udph->uh_sum));
+	fprintf_ip_header(fp, iph);
+	fprintf_eth_header(fp, ethh);
+	fprintf(fp, "------------------------------------------------------\n");
+}
+
+static int nmap_udp_global_initialize(struct state_conf *state)
+{
+	num_ports = state->source_port_last - state->source_port_first + 1;
+
+	return EXIT_SUCCESS;
+}
+
+static int nmap_udp_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+				  port_h_t dst_port,
+				  __attribute__((unused)) void **arg_ptr)
+{
+    memset(buf, 0, MAX_PACKET_SIZE);
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	make_eth_header(eth_header, src, gw);
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+    uint16_t ip_len = htons(328);
+	make_ip_header(ip_header, IPPROTO_UDP, ip_len);
+
+    struct udphdr *udp_header = (struct udphdr *)(&ip_header[1]);
+	uint32_t len = 308;
+	make_udp_header(udp_header, zconf.target_port, len);
+
+    char *payload = (char *)(&udp_header[1]);
+    memset(payload, 0x43, 300);
+
+	return EXIT_SUCCESS;
+}
+
+static int nmap_udp_make_packet(void *buf, UNUSED size_t *buf_len,
+			       ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+			       uint32_t *validation, int probe_num,
+			       UNUSED void *arg)
+{
+	struct ether_header *eth_header = (struct ether_header *)buf;
+	struct ip *ip_header = (struct ip *)(&eth_header[1]);
+	struct udphdr *udp_header = (struct udphdr *)&ip_header[1];
+
+    ip_header->ip_src.s_addr = src_ip;
+	ip_header->ip_dst.s_addr = dst_ip;
+    ip_header->ip_id = htons(0x1042);
+	ip_header->ip_ttl = ttl;
+    udp_header->uh_sport = htons(43213);
+
+	ip_header->ip_sum = 0;
+	ip_header->ip_sum = zmap_ip_checksum((unsigned short *)ip_header);
+
+	return EXIT_SUCCESS;
+}
+
+static int nmap_udp_validate_packet(const struct ip *ip_hdr, UNUSED uint32_t len,
+				   __attribute__((unused)) uint32_t *src_ip,
+				   uint32_t *validation)
+{
+	if (ip_hdr->ip_p == IPPROTO_UDP) {
+		if ((4 * ip_hdr->ip_hl + sizeof(struct udphdr)) > len) {
+			// buffer not large enough to contain expected udp
+			// header
+			return PACKET_INVALID;
+		}
+		struct udphdr *udp =
+		    (struct udphdr *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+		uint16_t sport = ntohs(udp->uh_dport);
+		if (!check_dst_port(sport, num_ports, validation)) {
+			return PACKET_INVALID;
+		}
+		if (!blacklist_is_allowed(*src_ip)) {
+			return PACKET_INVALID;
+		}
+	} else if (ip_hdr->ip_p == IPPROTO_ICMP) {
+		// UDP can return ICMP Destination unreach
+		// IP( ICMP( IP( UDP ) ) ) for a destination unreach
+		const uint32_t min_len =
+		    4 * ip_hdr->ip_hl + ICMP_UNREACH_HEADER_SIZE +
+		    sizeof(struct ip) + sizeof(struct udphdr);
+		if (len < min_len) {
+			// Not enough information for us to validate
+			return PACKET_INVALID;
+		}
+		struct icmp *icmp =
+		    (struct icmp *)((char *)ip_hdr + 4 * ip_hdr->ip_hl);
+		if (icmp->icmp_type != ICMP_UNREACH) {
+			return PACKET_INVALID;
+		}
+		struct ip *ip_inner =
+		    (struct ip *)((char *)icmp + ICMP_UNREACH_HEADER_SIZE);
+		// Now we know the actual inner ip length, we should recheck the
+		// buffer
+		if (len < 4 * ip_inner->ip_hl - sizeof(struct ip) + min_len) {
+			return PACKET_INVALID;
+		}
+		// find original destination IP and check that we sent a packet
+		// to that IP address
+		uint32_t dest = ip_inner->ip_dst.s_addr;
+		if (!blacklist_is_allowed(dest)) {
+			return PACKET_INVALID;
+		}
+		// This is the UDP packet we sent
+		struct udphdr *udp =
+		    (struct udphdr *)((char *)ip_inner + 4 * ip_inner->ip_hl);
+		// we can always check the destination port because this is the
+		// original packet and wouldn't have been altered by something
+		// responding on a different port
+		uint16_t dport = ntohs(udp->uh_dport);
+		uint16_t sport = ntohs(udp->uh_sport);
+		if (dport != zconf.target_port) {
+			return PACKET_INVALID;
+		}
+		if (!check_dst_port(sport, num_ports, validation)) {
+			return PACKET_INVALID;
+		}
+	} else {
+		return PACKET_INVALID;
+	}
+
+	return PACKET_VALID;
+}
+
+static void nmap_udp_process_packet(const u_char *packet,
+				   __attribute__((unused)) uint32_t len,
+				   fieldset_t *fs,
+				   __attribute__((unused)) uint32_t *validation)
+
+{
+	struct ip *ip_hdr = (struct ip *)&packet[sizeof(struct ether_header)];
+    uint32_t packet_size = htons(ip_hdr->ip_len) + sizeof(struct ether_header); // add ethernet bytes
+
+    fs_add_binary(fs, "bitstring", packet_size, (void *) packet, 0);
+    fs_add_bool(fs, "success", 1);
+}
+
+static fielddef_t fields[] = {
+    {.name = "bitstring", .type= "binary", .desc = "bitstring of packet"},
+    {.name = "sport", .type = "int", .desc = "TCP source port"},
+    {.name = "dport", .type = "int", .desc = "TCP destination port"},
+    {.name = "seqnum", .type = "int", .desc = "TCP sequence number"},
+    {.name = "classification",
+     .type = "string",
+     .desc = "packet classification"},
+    {.name = "success",
+     .type = "bool",
+     .desc = "is response considered success"}};
+
+probe_module_t module_nmap_udp = {
+    .name = "nmap_udp",
+    .packet_length = 342,
+    .pcap_filter = "udp || icmp",
+    .pcap_snaplen = 1500,
+    .port_args = 1,
+    .global_initialize = &nmap_udp_global_initialize,
+    .thread_initialize = &nmap_udp_init_perthread,
+    .make_packet = &nmap_udp_make_packet,
+    .print_packet = &nmap_udp_print_packet,
+    .process_packet = &nmap_udp_process_packet,
+    .validate_packet = &nmap_udp_validate_packet,
+    .close = NULL,
+    .helptext = "Probe module that implements nmap closed port probes",
+    .output_type = OUTPUT_TYPE_STATIC,
+    .fields = fields,
+    .numfields = 6};
diff --git a/src/probe_modules/module_nmap_udp.h b/src/probe_modules/module_nmap_udp.h
new file mode 100644
index 0000000..7e469ff
--- /dev/null
+++ b/src/probe_modules/module_nmap_udp.h
@@ -0,0 +1,42 @@
+/*
+ * ZMap Copyright 2013 Regents of the University of Michigan
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy
+ * of the License at http://www.apache.org/licenses/LICENSE-2.0
+ */
+
+// probe module for performing TCP SYN scans
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "../../lib/includes.h"
+#include "../fieldset.h"
+#include "probe_modules.h"
+#include "packet.h"
+
+int nmap_global_initialize(struct state_conf *state);
+
+int nmap_udp_init_perthread(void *buf, macaddr_t *src, macaddr_t *gw,
+			   port_h_t dst_port,
+			   __attribute__((unused)) void **arg_ptr);
+
+int nmap_udp_make_packet(void *buf, ipaddr_n_t src_ip, ipaddr_n_t dst_ip, uint8_t ttl,
+			uint32_t *validation, int probe_num,
+			__attribute__((unused)) void *arg);
+
+void nmap_udp_print_packet(FILE *fp, void *packet);
+
+int nmap_udp_validate_packet(const struct ip *ip_hdr, uint32_t len,
+			    __attribute__((unused)) uint32_t *src_ip,
+			    uint32_t *validation);
+
+void nmap_udp_process_packet(const u_char *packet,
+			    __attribute__((unused)) uint32_t len,
+			    fieldset_t *fs,
+			    __attribute__((unused)) uint32_t *validation);
diff --git a/src/probe_modules/probe_modules.c b/src/probe_modules/probe_modules.c
index 15fc39f..331aeb5 100644
--- a/src/probe_modules/probe_modules.c
+++ b/src/probe_modules/probe_modules.c
@@ -20,6 +20,7 @@
 #include "packet.h"
 
 // extern probe_module_t module_tcp_cisco_backdoor;
+// INCLUDED IPv4 PROBES
 extern probe_module_t module_tcp_synscan;
 extern probe_module_t module_tcp_synackscan;
 extern probe_module_t module_icmp_echo;
@@ -30,11 +31,20 @@ extern probe_module_t module_upnp;
 extern probe_module_t module_dns;
 extern probe_module_t module_bacnet;
 extern probe_module_t module_tcp_synopt;
+// CUSTOM IPv4 PROBES
+extern probe_module_t module_icmp_timestamp;
+extern probe_module_t module_icmp_reply;
+extern probe_module_t module_nmap_tcp;
+extern probe_module_t module_nmap_udp;
+extern probe_module_t module_nmap_icmp_echo_1;
+extern probe_module_t module_nmap_icmp_echo_2;
+// INCLUDED IPv6 PROBES
 extern probe_module_t module_ipv6_tcp_synscan;
 extern probe_module_t module_ipv6_tcp_synopt;
 extern probe_module_t module_ipv6_udp;
 extern probe_module_t module_ipv6_udp_dns;
 extern probe_module_t module_icmp6_echoscan;
+// CUSTOM IPv6 PROBES
 extern probe_module_t module_icmp6_nmap_echo_1;
 extern probe_module_t module_icmp6_nmap_echo_2;
 extern probe_module_t module_icmp6_nmap_node_req;
@@ -60,6 +70,11 @@ probe_module_t* probe_modules[] = {
 	&module_ipv6_udp,
 	&module_ipv6_udp_dns,
 	&module_icmp6_echoscan,
+
+    &module_nmap_tcp, &module_nmap_udp, &module_nmap_icmp_echo_1,
+    &module_nmap_icmp_echo_2,
+    &module_icmp_timestamp, &module_icmp_reply,
+	
 	&module_icmp6_nmap_echo_1,
 	&module_icmp6_nmap_echo_2,
 	&module_icmp6_nmap_node_req,
-- 
2.20.1


From 1565a56bdc9d8efb077346b087151d552eb2e182 Mon Sep 17 00:00:00 2001
From: Ross Teixeira <rapt@cs.princeton.edu>
Date: Wed, 18 Mar 2020 06:35:44 +0000
Subject: [PATCH 3/3] run both

---
 capture.sh  | 2 +-
 ipv4.txt    | 1 +
 run_zmap.sh | 7 ++++++-
 3 files changed, 8 insertions(+), 2 deletions(-)
 create mode 100644 ipv4.txt

diff --git a/capture.sh b/capture.sh
index 1da2a36..fb2a503 100755
--- a/capture.sh
+++ b/capture.sh
@@ -1,3 +1,3 @@
 #!/bin/bash
 
-sudo tshark -V -f "src host fe80::1e69:7aff:fe60:7aa5" -P -o udp.check_checksum:TRUE -o tcp.check_checksum:TRUE
\ No newline at end of file
+sudo tshark -V -f "(src host fe80::1e69:7aff:fe60:7aa5) || (src host 1.1.1.1)" -P -o "udp.check_checksum:TRUE" -o "tcp.check_checksum:TRUE"
\ No newline at end of file
diff --git a/ipv4.txt b/ipv4.txt
new file mode 100644
index 0000000..6c04221
--- /dev/null
+++ b/ipv4.txt
@@ -0,0 +1 @@
+8.8.8.8
\ No newline at end of file
diff --git a/run_zmap.sh b/run_zmap.sh
index 60acbe8..fddfe42 100755
--- a/run_zmap.sh
+++ b/run_zmap.sh
@@ -1,4 +1,9 @@
 #!/bin/bash
 ./compile.sh
 wait
-sudo zmap -p 20023 -M $1 --ipv6-target-file=ipv6.txt --ipv6-source-ip=fe80::1e69:7aff:fe60:7aa5 --probe-args=$2
\ No newline at end of file
+
+case $1 in
+  4) sudo zmap -p 20023 -M $2 --whitelist-file=ipv4.txt --source-ip=1.1.1.1 --probe-args=$3;;
+  6) sudo zmap -p 20023 -M $2 --ipv6-target-file=ipv6.txt --source-ip=1.1.1.1 --ipv6-source-ip=fe80::1e69:7aff:fe60:7aa5 --probe-args=$3;;
+  *) echo "Please begin your command with '4' or '6'" && exit;
+esac
\ No newline at end of file
-- 
2.20.1

